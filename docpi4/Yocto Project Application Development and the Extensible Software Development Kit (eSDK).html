<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0111)https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-running-the-sdk-environment-setup-script -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Yocto Project Application Development and the Extensible Software Development Kit (eSDK)</title><link rel="stylesheet" type="text/css" href="./Yocto Project Application Development and the Extensible Software Development Kit (eSDK)_files/sdk-style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"></head><body><div xml:lang="en" class="book" title="Yocto Project Application Development and the Extensible Software Development Kit (eSDK)" id="sdk-manual" lang="en"><div class="titlepage"><div><div><h1 class="title">
            Yocto Project Application Development and the Extensible Software Development Kit (eSDK)
        </h1></div><div><div class="authorgroup">
            <div class="author"><h3 class="author"><span class="firstname">Scott</span> <span class="surname">Rifenbark</span></h3><div class="affiliation">
                    <span class="orgname">Scotty's Documentation Services, INC<br></span>
                </div><code class="email">&lt;<a class="email" href="mailto:srifenbark@gmail.com">srifenbark@gmail.com</a>&gt;</code></div>
        </div></div><div><p class="copyright">Copyright Â© 2010-2019 Linux Foundation</p></div><div><div class="legalnotice" title="Legal Notice"><a id="idm45641560128992"></a>
      <p>
        Permission is granted to copy, distribute and/or modify this document under
        the terms of the <a class="ulink" href="http://creativecommons.org/licenses/by-sa/2.0/uk/" target="_top">Creative Commons Attribution-Share Alike 2.0 UK: England &amp; Wales</a> as published by Creative Commons.
      </p>
           <div class="note" title="Manual Notes" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Manual Notes</h3>
               <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                       This version of the
                       <span class="emphasis"><em>Yocto Project Application Development and the Extensible Software Development Kit (eSDK)</em></span>
                       manual is for the 3.0.1 release of the
                       Yocto Project.
                       To be sure you have the latest version of the manual
                       for this release, go to the
                       <a class="ulink" href="http://www.yoctoproject.org/documentation" target="_top">Yocto Project documentation page</a>
                       and select the manual from that site.
                       Manuals from the site are more up-to-date than manuals
                       derived from the Yocto Project released TAR files.
                       </p></li><li class="listitem"><p>
                       If you located this manual through a web search, the
                       version of the manual might not be the one you want
                       (e.g. the search might have returned a manual much
                       older than the Yocto Project version with which you
                       are working).
                       You can see all Yocto Project major releases by
                       visiting the
                       <a class="ulink" href="https://wiki.yoctoproject.org/wiki/Releases" target="_top">Releases</a>
                       page.
                       If you need a version of this manual for a different
                       Yocto Project release, visit the
                       <a class="ulink" href="http://www.yoctoproject.org/documentation" target="_top">Yocto Project documentation page</a>
                       and select the manual set by using the
                       "ACTIVE RELEASES DOCUMENTATION" or "DOCUMENTS ARCHIVE"
                       pull-down menus.
                       </p></li><li class="listitem"><p>
                       To report any inaccuracies or problems with this
                       manual, send an email to the Yocto Project
                       discussion group at
                       <code class="filename">yocto@yoctoproject.com</code> or log into
                       the freenode <code class="filename">#yocto</code> channel.
                       </p></li></ul></div>
           </div>
    </div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tbody><tr><th align="left" valign="top" colspan="2"><strong>Revision History</strong></th></tr>
            <tr><td align="left">Revision 2.1</td><td align="left">April 2016</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.1 Release.</td></tr>
            <tr><td align="left">Revision 2.2</td><td align="left">October 2016</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.2 Release.</td></tr>
            <tr><td align="left">Revision 2.3</td><td align="left">May 2017</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.3 Release.</td></tr>
            <tr><td align="left">Revision 2.4</td><td align="left">October 2017</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.4 Release.</td></tr>
            <tr><td align="left">Revision 2.5</td><td align="left">May 2018</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.5 Release.</td></tr>
            <tr><td align="left">Revision 2.6</td><td align="left">November 2018</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.6 Release.</td></tr>
            <tr><td align="left">Revision 2.7</td><td align="left">May 2019</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.7 Release.</td></tr>
            <tr><td align="left">Revision 3.0</td><td align="left">October</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 3.0 Release.</td></tr>
            <tr><td align="left">Revision 3.0.1</td><td align="left">December 2019</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 3.0.1 Release.</td></tr>
       </tbody></table></div></div></div><hr></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-intro">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-manual-intro">1.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#the-cross-development-toolchain">1.1.1. The Cross-Development Toolchain</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sysroot">1.1.2. Sysroots</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#the-qemu-emulator">1.1.3. The QEMU Emulator</a></span></dt></dl></dd><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-development-model">1.2. SDK Development Model</a></span></dt></dl></dd><dt><span class="chapter"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-extensible">2. Using the Extensible SDK</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-extensible-sdk-intro">2.1. Why use the Extensible SDK and What is in It?</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installing-the-extensible-sdk">2.2. Installing the Extensible SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-running-the-extensible-sdk-environment-setup-script">2.3. Running the Extensible SDK Environment Setup Script</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#using-devtool-in-your-sdk-workflow">2.4. Using <code class="filename">devtool</code> in Your SDK Workflow</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-use-devtool-to-add-an-application">2.4.1. Use <code class="filename">devtool add</code> to Add an Application</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-devtool-use-devtool-modify-to-modify-the-source-of-an-existing-component">2.4.2. Use <code class="filename">devtool modify</code> to Modify the Source of an Existing Component</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-devtool-use-devtool-upgrade-to-create-a-version-of-the-recipe-that-supports-a-newer-version-of-the-software">2.4.3. Use <code class="filename">devtool upgrade</code> to Create a Version of the Recipe that Supports a Newer Version of the Software</a></span></dt></dl></dd><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-a-closer-look-at-devtool-add">2.5. A Closer Look at <code class="filename">devtool add</code></a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-name-and-version">2.5.1. Name and Version</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-dependency-detection-and-mapping">2.5.2. Dependency Detection and Mapping</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-license-detection">2.5.3. License Detection</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-makefile-only-software">2.5.4. Adding Makefile-Only Software</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-native-tools">2.5.5. Adding Native Tools</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-node-js-modules">2.5.6. Adding Node.js Modules</a></span></dt></dl></dd><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-working-with-recipes">2.6. Working With Recipes</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-finding-logs-and-work-files">2.6.1. Finding Logs and Work Files</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-setting-configure-arguments">2.6.2. Setting Configure Arguments</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-sharing-files-between-recipes">2.6.3. Sharing Files Between Recipes</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-packaging">2.6.4. Packaging</a></span></dt></dl></dd><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-restoring-the-target-device-to-its-original-state">2.7. Restoring the Target Device to its Original State</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installing-additional-items-into-the-extensible-sdk">2.8. Installing Additional Items Into the Extensible SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-applying-updates-to-an-installed-extensible-sdk">2.9. Applying Updates to an Installed Extensible SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-creating-a-derivative-sdk-with-additional-components">2.10. Creating a Derivative SDK With Additional Components</a></span></dt></dl></dd><dt><span class="chapter"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-using-the-standard-sdk">3. Using the Standard SDK</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-standard-sdk-intro">3.1. Why use the Standard SDK and What is in It?</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installing-the-sdk">3.2. Installing the SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-running-the-sdk-environment-setup-script">3.3. Running the SDK Environment Setup Script</a></span></dt></dl></dd><dt><span class="chapter"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-working-projects">4. Using the SDK Toolchain Directly</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#autotools-based-projects">4.1. Autotools-Based Projects</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#makefile-based-projects">4.2. Makefile-Based Projects</a></span></dt></dl></dd><dt><span class="appendix"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-appendix-obtain">A. Obtaining the SDK</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-locating-pre-built-sdk-installers">A.1. Locating Pre-Built SDK Installers</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-building-an-sdk-installer">A.2. Building an SDK Installer</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-extracting-the-root-filesystem">A.3. Extracting the Root Filesystem</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-standard-sdk-directory-structure">A.4. Installed Standard SDK Directory Structure</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-extensible-sdk-directory-structure">A.5. Installed Extensible SDK Directory Structure</a></span></dt></dl></dd><dt><span class="appendix"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-appendix-customizing">B. Customizing the Extensible SDK</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-configuring-the-extensible-sdk">B.1. Configuring the Extensible SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#adjusting-the-extensible-sdk-to-suit-your-build-hosts-setup">B.2. Adjusting the Extensible SDK to Suit Your Build Host's Setup</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-changing-the-sdk-installer-title">B.3. Changing the Extensible SDK Installer Title</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-providing-updates-to-the-extensible-sdk-after-installation">B.4. Providing Updates to the Extensible SDK After Installation</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-changing-the-default-sdk-installation-directory">B.5. Changing the Default SDK Installation Directory</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-providing-additional-installable-extensible-sdk-content">B.6. Providing Additional Installable Extensible SDK Content</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-minimizing-the-size-of-the-extensible-sdk-installer-download">B.7. Minimizing the Size of the Extensible SDK Installer Download</a></span></dt></dl></dd><dt><span class="appendix"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-appendix-customizing-standard">C. Customizing the Standard SDK</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-individual-packages">C.1. Adding Individual Packages to the Standard SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#adding-api-documentation-to-the-standard-sdk">C.2. Adding API Documentation to the Standard SDK</a></span></dt></dl></dd></dl></div>
    

    <div class="chapter" title="ChapterÂ 1.Â Introduction" id="sdk-intro"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;1.&nbsp;Introduction<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-intro">Â¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-manual-intro">1.1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#the-cross-development-toolchain">1.1.1. The Cross-Development Toolchain</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sysroot">1.1.2. Sysroots</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#the-qemu-emulator">1.1.3. The QEMU Emulator</a></span></dt></dl></dd><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-development-model">1.2. SDK Development Model</a></span></dt></dl></div><div class="section" title="1.1.Â Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-manual-intro">1.1.&nbsp;Introduction<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-manual-intro">Â¶</a></span></h2></div></div></div><p>
        Welcome to the Yocto Project Application Development and the
        Extensible Software Development Kit (eSDK) manual.
        This manual provides information that explains how to use both the
        Yocto Project extensible and standard SDKs to develop
        applications and images.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            Prior to the 2.0 Release of the Yocto Project, application
            development was primarily accomplished through the use of the
            Application Development Toolkit (ADT) and the availability
            of stand-alone cross-development toolchains and other tools.
            With the 2.1 Release of the Yocto Project, application development
            has transitioned to within a tool-rich extensible SDK and the more
            traditional standard SDK.
        </div><p>
    </p><p>
        All SDKs consist of the following:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                <span class="emphasis"><em>Cross-Development Toolchain</em></span>:
                This toolchain contains a compiler, debugger, and various
                miscellaneous tools.
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Libraries, Headers, and Symbols</em></span>:
                The libraries, headers, and symbols are specific to the image
                (i.e. they match the image).
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Environment Setup Script</em></span>:
                This <code class="filename">*.sh</code> file, once run, sets up the
                cross-development environment by defining variables and
                preparing for SDK use.
                </p></li></ul></div><p>
    </p><p>
        Additionally, an extensible SDK has tools that allow you to easily add
        new applications and libraries to an image, modify the source of an
        existing component, test changes on the target hardware, and easily
        integrate an application into the
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#build-system-term" target="_top">OpenEmbedded build system</a>.
    </p><p>
        You can use an SDK to independently develop and test code
        that is destined to run on some target machine.
        SDKs are completely self-contained.
        The binaries are linked against their own copy of
        <code class="filename">libc</code>, which results in no dependencies
        on the target system.
        To achieve this, the pointer to the dynamic loader is
        configured at install time since that path cannot be dynamically
        altered.
        This is the reason for a wrapper around the
        <code class="filename">populate_sdk</code> and
        <code class="filename">populate_sdk_ext</code> archives.
    </p><p>
        Another feature for the SDKs is that only one set of cross-compiler
        toolchain binaries are produced for any given architecture.
        This feature takes advantage of the fact that the target hardware can
        be passed to <code class="filename">gcc</code> as a set of compiler options.
        Those options are set up by the environment script and contained in
        variables such as
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-CC" target="_top"><code class="filename">CC</code></a>
        and
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-LD" target="_top"><code class="filename">LD</code></a>.
        This reduces the space needed for the tools.
        Understand, however, that every target still needs a sysroot because
        those binaries are target-specific.
    </p><p>
        The SDK development environment consists of the following:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                The self-contained SDK, which is an
                architecture-specific cross-toolchain and
                matching sysroots (target and native) all built by the
                OpenEmbedded build system (e.g. the SDK).
                The toolchain and sysroots are based on a
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#metadata" target="_top">Metadata</a>
                configuration and extensions,
                which allows you to cross-develop on the host machine for the
                target hardware.
                Additionally, the extensible SDK contains the
                <code class="filename">devtool</code> functionality.
                </p></li><li class="listitem"><p>
                The Quick EMUlator (QEMU), which lets you simulate
                target hardware.
                QEMU is not literally part of the SDK.
                You must build and include this emulator separately.
                However, QEMU plays an important role in the development
                process that revolves around use of the SDK.
                </p></li></ul></div><p>
    </p><p>
        In summary, the extensible and standard SDK share many features.
        However, the extensible SDK has powerful development tools to help you
        more quickly develop applications.
        Following is a table that summarizes the primary differences between
        the standard and extensible SDK types when considering which to
        build:
        </p><div class="informaltable"><table border="0"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left"><span class="emphasis"><em>Feature</em></span></th><th align="left"><span class="emphasis"><em>Standard SDK</em></span></th><th align="left"><span class="emphasis"><em>Extensible SDK</em></span></th></tr></thead><tbody><tr><td align="left">Toolchain</td><td align="left">Yes</td><td align="left">Yes*</td></tr><tr><td align="left">Debugger</td><td align="left">Yes</td><td align="left">Yes*</td></tr><tr><td align="left">Size</td><td align="left">100+ MBytes</td><td align="left">1+ GBytes (or 300+ MBytes for minimal w/toolchain)</td></tr><tr><td align="left"><code class="filename">devtool</code></td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Build Images</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Updateable</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Managed Sysroot**</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Installed Packages</td><td align="left">No***</td><td align="left">Yes****</td></tr><tr><td align="left">Construction</td><td align="left">Packages</td><td align="left">Shared State</td></tr></tbody></table></div><p>
        </p><pre class="literallayout">     * Extensible SDK contains the toolchain and debugger if <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_EXT_TYPE" target="_top"><code class="filename">SDK_EXT_TYPE</code></a> is "full" or <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_INCLUDE_TOOLCHAIN" target="_top"><code class="filename">SDK_INCLUDE_TOOLCHAIN</code></a> is "1", which is the default.

     ** Sysroot is managed through the use of <code class="filename">devtool</code>.  Thus, it is less likely that you will corrupt your SDK sysroot when you try to add additional libraries.

     *** You can add runtime package management to the standard SDK but it is not supported by default.

     **** You must build and make the shared state available to extensible SDK users for "packages" you want to enable users to install.
        </pre><p>
    </p><div class="section" title="1.1.1.Â The Cross-Development Toolchain"><div class="titlepage"><div><div><h3 class="title" id="the-cross-development-toolchain">1.1.1.&nbsp;The Cross-Development Toolchain<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#the-cross-development-toolchain">Â¶</a></span></h3></div></div></div><p>
            The
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#cross-development-toolchain" target="_top">Cross-Development Toolchain</a>
            consists of a cross-compiler, cross-linker, and cross-debugger
            that are used to develop user-space applications for targeted
            hardware.
            Additionally, for an extensible SDK, the toolchain also has
            built-in <code class="filename">devtool</code> functionality.
            This toolchain is created by running a SDK installer script
            or through a
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#build-directory" target="_top">Build Directory</a>
            that is based on your metadata configuration or extension for
            your targeted device.
            The cross-toolchain works with a matching target sysroot.
        </p></div><div class="section" title="1.1.2.Â Sysroots"><div class="titlepage"><div><div><h3 class="title" id="sysroot">1.1.2.&nbsp;Sysroots<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sysroot">Â¶</a></span></h3></div></div></div><p>
            The native and target sysroots contain needed headers and libraries
            for generating binaries that run on the target architecture.
            The target sysroot is based on the target root filesystem image
            that is built by the OpenEmbedded build system and uses the same
            metadata configuration used to build the cross-toolchain.
        </p></div><div class="section" title="1.1.3.Â The QEMU Emulator"><div class="titlepage"><div><div><h3 class="title" id="the-qemu-emulator">1.1.3.&nbsp;The QEMU Emulator<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#the-qemu-emulator">Â¶</a></span></h3></div></div></div><p>
            The QEMU emulator allows you to simulate your hardware while
            running your application or image.
            QEMU is not part of the SDK but is made available a number of
            different ways:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    If you have cloned the <code class="filename">poky</code> Git
                    repository to create a
                    <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#source-directory" target="_top">Source Directory</a>
                    and you have sourced the environment setup script, QEMU is
                    installed and automatically available.
                    </p></li><li class="listitem"><p>
                    If you have downloaded a Yocto Project release and unpacked
                    it to create a Source Directory and you have sourced the
                    environment setup script, QEMU is installed and
                    automatically available.
                    </p></li><li class="listitem"><p>
                    If you have installed the cross-toolchain tarball and you
                    have sourced the toolchain's setup environment script, QEMU
                    is also installed and automatically available.
                    </p></li></ul></div><p>
        </p></div></div><div class="section" title="1.2.Â SDK Development Model"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-development-model">1.2.&nbsp;SDK Development Model<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-development-model">Â¶</a></span></h2></div></div></div><p>
        Fundamentally, the SDK fits into the development process as follows:
        </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tbody><tr style="height: 450px"><td align="center"><img src="./Yocto Project Application Development and the Extensible Software Development Kit (eSDK)_files/sdk-environment.png" align="middle" width="540"></td></tr></tbody></table><p>
        The SDK is installed on any machine and can be used to develop
        applications, images, and kernels.
        An SDK can even be used by a QA Engineer or Release Engineer.
        The fundamental concept is that the machine that has the SDK installed
        does not have to be associated with the machine that has the
        Yocto Project installed.
        A developer can independently compile and test an object on their
        machine and then, when the object is ready for integration into an
        image, they can simply make it available to the machine that has the
        Yocto Project.
        Once the object is available, the image can be rebuilt using the
        Yocto Project to produce the modified image.
    </p><p>
        You just need to follow these general steps:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <span class="emphasis"><em>Install the SDK for your target hardware:</em></span>
                For information on how to install the SDK, see the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installing-the-sdk" title="3.2.Â Installing the SDK">Installing the SDK</a>"
                section.
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Download or Build the Target Image:</em></span>
                The Yocto Project supports several target architectures
                and has many pre-built kernel images and root filesystem
                images.</p><p>If you are going to develop your application on
                hardware, go to the
                <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-3.0.1/machines" target="_top"><code class="filename">machines</code></a>
                download area and choose a target machine area
                from which to download the kernel image and root filesystem.
                This download area could have several files in it that
                support development using actual hardware.
                For example, the area might contain
                <code class="filename">.hddimg</code> files that combine the
                kernel image with the filesystem, boot loaders, and
                so forth.
                Be sure to get the files you need for your particular
                development process.</p><p>If you are going to develop your application and
                then run and test it using the QEMU emulator, go to the
                <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-3.0.1/machines/qemu" target="_top"><code class="filename">machines/qemu</code></a>
                download area.
                From this area, go down into the directory for your
                target architecture (e.g. <code class="filename">qemux86_64</code>
                for an <span class="trademark">Intel</span>Â®-based
                64-bit architecture).
                Download the kernel, root filesystem, and any other files you
                need for your process.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    To use the root filesystem in QEMU, you need to extract it.
                    See the
                    "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-extracting-the-root-filesystem" title="A.3.Â Extracting the Root Filesystem">Extracting the Root Filesystem</a>"
                    section for information on how to extract the root
                    filesystem.
                </div><p>
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Develop and Test your Application:</em></span>
                At this point, you have the tools to develop your application.
                If you need to separately install and use the QEMU emulator,
                you can go to
                <a class="ulink" href="http://wiki.qemu.org/Main_Page" target="_top">QEMU Home Page</a>
                to download and learn about the emulator.
                See the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/dev-manual/dev-manual.html#dev-manual-qemu" target="_top">Using the Quick EMUlator (QEMU)</a>"
                chapter in the Yocto Project Development Tasks Manual
                for information on using QEMU within the Yocto
                Project.
                </p></li></ol></div><p>
    </p><p>
        The remainder of this manual describes how to use the extensible
        and standard SDKs.
        Information also exists in appendix form that describes how you can
        build, install, and modify an SDK.
    </p></div></div>

    <div class="chapter" title="ChapterÂ 2.Â Using the Extensible SDK" id="sdk-extensible"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;2.&nbsp;Using the Extensible SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-extensible">Â¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-extensible-sdk-intro">2.1. Why use the Extensible SDK and What is in It?</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installing-the-extensible-sdk">2.2. Installing the Extensible SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-running-the-extensible-sdk-environment-setup-script">2.3. Running the Extensible SDK Environment Setup Script</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#using-devtool-in-your-sdk-workflow">2.4. Using <code class="filename">devtool</code> in Your SDK Workflow</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-use-devtool-to-add-an-application">2.4.1. Use <code class="filename">devtool add</code> to Add an Application</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-devtool-use-devtool-modify-to-modify-the-source-of-an-existing-component">2.4.2. Use <code class="filename">devtool modify</code> to Modify the Source of an Existing Component</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-devtool-use-devtool-upgrade-to-create-a-version-of-the-recipe-that-supports-a-newer-version-of-the-software">2.4.3. Use <code class="filename">devtool upgrade</code> to Create a Version of the Recipe that Supports a Newer Version of the Software</a></span></dt></dl></dd><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-a-closer-look-at-devtool-add">2.5. A Closer Look at <code class="filename">devtool add</code></a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-name-and-version">2.5.1. Name and Version</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-dependency-detection-and-mapping">2.5.2. Dependency Detection and Mapping</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-license-detection">2.5.3. License Detection</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-makefile-only-software">2.5.4. Adding Makefile-Only Software</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-native-tools">2.5.5. Adding Native Tools</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-node-js-modules">2.5.6. Adding Node.js Modules</a></span></dt></dl></dd><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-working-with-recipes">2.6. Working With Recipes</a></span></dt><dd><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-finding-logs-and-work-files">2.6.1. Finding Logs and Work Files</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-setting-configure-arguments">2.6.2. Setting Configure Arguments</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-sharing-files-between-recipes">2.6.3. Sharing Files Between Recipes</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-packaging">2.6.4. Packaging</a></span></dt></dl></dd><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-restoring-the-target-device-to-its-original-state">2.7. Restoring the Target Device to its Original State</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installing-additional-items-into-the-extensible-sdk">2.8. Installing Additional Items Into the Extensible SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-applying-updates-to-an-installed-extensible-sdk">2.9. Applying Updates to an Installed Extensible SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-creating-a-derivative-sdk-with-additional-components">2.10. Creating a Derivative SDK With Additional Components</a></span></dt></dl></div><p>
        This chapter describes the extensible SDK and how to install it.
        Information covers the pieces of the SDK, how to install it, and
        presents a look at using the <code class="filename">devtool</code>
        functionality.
        The extensible SDK makes it easy to add new applications and libraries
        to an image, modify the source for an existing component, test
        changes on the target hardware, and ease integration into the rest of
        the
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#build-system-term" target="_top">OpenEmbedded build system</a>.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            For a side-by-side comparison of main features supported for an
            extensible SDK as compared to a standard SDK, see the
            "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-manual-intro" title="1.1.Â Introduction">Introduction</a>"
            section.
        </div><p>
    </p><p>
        In addition to the functionality available through
        <code class="filename">devtool</code>, you can alternatively make use of the
        toolchain directly, for example from Makefile and Autotools.
        See the
        "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-working-projects" title="ChapterÂ 4.Â Using the SDK Toolchain Directly">Using the SDK Toolchain Directly</a>"
        chapter for more information.
    </p><div class="section" title="2.1.Â Why use the Extensible SDK and What is in It?"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-extensible-sdk-intro">2.1.&nbsp;Why use the Extensible SDK and What is in It?<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-extensible-sdk-intro">Â¶</a></span></h2></div></div></div><p>
            The extensible SDK provides a cross-development toolchain and
            libraries tailored to the contents of a specific image.
            You would use the Extensible SDK if you want a toolchain experience
            supplemented with the powerful set of <code class="filename">devtool</code>
            commands tailored for the Yocto Project environment.
        </p><p>
            The installed extensible SDK consists of several files and
            directories.
            Basically, it contains an SDK environment setup script, some
            configuration files, an internal build system, and the
            <code class="filename">devtool</code> functionality.
        </p></div><div class="section" title="2.2.Â Installing the Extensible SDK"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-installing-the-extensible-sdk">2.2.&nbsp;Installing the Extensible SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installing-the-extensible-sdk">Â¶</a></span></h2></div></div></div><p>
            The first thing you need to do is install the SDK on your
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#hardware-build-system-term" target="_top">Build Host</a>
            by running the <code class="filename">*.sh</code> installation script.
        </p><p>
            You can download a tarball installer, which includes the
            pre-built toolchain, the <code class="filename">runqemu</code>
            script, the internal build system, <code class="filename">devtool</code>,
            and support files from the appropriate
            <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-3.0.1/toolchain/" target="_top">toolchain</a>
            directory within the Index of Releases.
            Toolchains are available for several 32-bit and 64-bit
            architectures with the <code class="filename">x86_64</code> directories,
            respectively.
            The toolchains the Yocto Project provides are based off the
            <code class="filename">core-image-sato</code> and
            <code class="filename">core-image-minimal</code> images and contain
            libraries appropriate for developing against that image.
        </p><p>
            The names of the tarball installer scripts are such that a
            string representing the host system appears first in the
            filename and then is immediately followed by a string
            representing the target architecture.
            An extensible SDK has the string "-ext" as part of the name.
            Following is the general form:
            </p><pre class="literallayout">     poky-glibc-<em class="replaceable"><code>host_system</code></em>-<em class="replaceable"><code>image_type</code></em>-<em class="replaceable"><code>arch</code></em>-toolchain-ext-<em class="replaceable"><code>release_version</code></em>.sh

     Where:
         <em class="replaceable"><code>host_system</code></em> is a string representing your development system:

                    i686 or x86_64.

         <em class="replaceable"><code>image_type</code></em> is the image for which the SDK was built:

                    core-image-sato or core-image-minimal

         <em class="replaceable"><code>arch</code></em> is a string representing the tuned target architecture:

                    aarch64, armv5e, core2-64, i586, mips32r2, mips64, ppc7400, or cortexa8hf-neon

         <em class="replaceable"><code>release_version</code></em> is a string representing the release number of the Yocto Project:

                    3.0.1, 3.0.1+snapshot
            </pre><p>
            For example, the following SDK installer is for a 64-bit
            development host system and a i586-tuned target architecture
            based off the SDK for <code class="filename">core-image-sato</code> and
            using the current 3.0.1 snapshot:
            </p><pre class="literallayout">     poky-glibc-x86_64-core-image-sato-i586-toolchain-ext-3.0.1.sh
            </pre><p>
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                As an alternative to downloading an SDK, you can build the
                SDK installer.
                For information on building the installer, see the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-building-an-sdk-installer" title="A.2.Â Building an SDK Installer">Building an SDK Installer</a>"
                section.
            </div><p>
        </p><p>
            The SDK and toolchains are self-contained and by default are
            installed into the <code class="filename">poky_sdk</code> folder in your
            home directory.
            You can choose to install the extensible SDK in any location when
            you run the installer.
            However, because files need to be written under that directory
            during the normal course of operation, the location you choose
            for installation must be writable for whichever
            users need to use the SDK.
        </p><p>
            The following command shows how to run the installer given a
            toolchain tarball for a 64-bit x86 development host system and
            a 64-bit x86 target architecture.
            The example assumes the SDK installer is located in
            <code class="filename">~/Downloads/</code> and has execution rights.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                If you do not have write permissions for the directory
                into which you are installing the SDK, the installer
                notifies you and exits.
                For that case, set up the proper permissions in the directory
                and run the installer again.
            </div><p>
            </p><pre class="literallayout">     $ ./Downloads/poky-glibc-x86_64-core-image-minimal-core2-64-toolchain-ext-2.5.sh
     Poky (Yocto Project Reference Distro) Extensible SDK installer version 2.5
     ==========================================================================
     Enter target directory for SDK (default: ~/poky_sdk):
     You are about to install the SDK to "/home/scottrif/poky_sdk". Proceed [Y/n]? Y
     Extracting SDK..............done
     Setting it up...
     Extracting buildtools...
     Preparing build system...
     Parsing recipes: 100% |##################################################################| Time: 0:00:52
     Initialising tasks: 100% |###############################################################| Time: 0:00:00
     Checking sstate mirror object availability: 100% |#######################################| Time: 0:00:00
     Loading cache: 100% |####################################################################| Time: 0:00:00
     Initialising tasks: 100% |###############################################################| Time: 0:00:00
     done
     SDK has been successfully set up and is ready to be used.
     Each time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g.
      $ . /home/scottrif/poky_sdk/environment-setup-core2-64-poky-linux

            </pre><p>
        </p></div><div class="section" title="2.3.Â Running the Extensible SDK Environment Setup Script"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-running-the-extensible-sdk-environment-setup-script">2.3.&nbsp;Running the Extensible SDK Environment Setup Script<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-running-the-extensible-sdk-environment-setup-script">Â¶</a></span></h2></div></div></div><p>
            Once you have the SDK installed, you must run the SDK environment
            setup script before you can actually use the SDK.
            This setup script resides in the directory you chose when you
            installed the SDK, which is either the default
            <code class="filename">poky_sdk</code> directory or the directory you
            chose during installation.
        </p><p>
            Before running the script, be sure it is the one that matches the
            architecture for which you are developing.
            Environment setup scripts begin with the string
            "<code class="filename">environment-setup</code>" and include as part of
            their name the tuned target architecture.
            As an example, the following commands set the working directory
            to where the SDK was installed and then source the environment
            setup script.
            In this example, the setup script is for an IA-based
            target machine using i586 tuning:
            </p><pre class="literallayout">     $ cd /home/scottrif/poky_sdk
     $ source environment-setup-core2-64-poky-linux
     SDK environment now set up; additionally you may now run devtool to perform development tasks.
     Run devtool --help for further details.
            </pre><p>
            Running the setup script defines many environment variables needed
            in order to use the SDK (e.g. <code class="filename">PATH</code>,
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-CC" target="_top"><code class="filename">CC</code></a>,
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-LD" target="_top"><code class="filename">LD</code></a>,
            and so forth).
            If you want to see all the environment variables the script
            exports, examine the installation file itself.
        </p></div><div class="section" title="2.4.Â Using devtool in Your SDK Workflow"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="using-devtool-in-your-sdk-workflow">2.4.&nbsp;Using <code class="filename">devtool</code> in Your SDK Workflow<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#using-devtool-in-your-sdk-workflow">Â¶</a></span></h2></div></div></div><p>
            The cornerstone of the extensible SDK is a command-line tool
            called <code class="filename">devtool</code>.
            This tool provides a number of features that help
            you build, test and package software within the extensible SDK, and
            optionally integrate it into an image built by the OpenEmbedded
            build system.
            </p><div class="note" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3>
                The use of <code class="filename">devtool</code> is not limited to
                the extensible SDK.
                You can use <code class="filename">devtool</code> to help you easily
                develop any project whose build output must be part of an
                image built using the build system.
            </div><p>
        </p><p>
            The <code class="filename">devtool</code> command line is organized
            similarly to
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/overview-manual/overview-manual.html#git" target="_top">Git</a> in that it
            has a number of sub-commands for each function.
            You can run <code class="filename">devtool --help</code> to see all the
            commands.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                See the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-devtool-reference" target="_top"><code class="filename">devtool</code>&nbsp;Quick Reference</a>"
                in the Yocto Project Reference Manual for a
                <code class="filename">devtool</code> quick reference.
            </div><p>
        </p><p>
            Three <code class="filename">devtool</code> subcommands exist that provide
            entry-points into development:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="emphasis"><em><code class="filename">devtool add</code></em></span>:
                    Assists in adding new software to be built.
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em><code class="filename">devtool modify</code></em></span>:
                    Sets up an environment to enable you to modify the source of
                    an existing component.
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em><code class="filename">devtool upgrade</code></em></span>:
                    Updates an existing recipe so that you can build it for
                    an updated set of source files.
                    </p></li></ul></div><p>
            As with the build system, "recipes" represent software packages
            within <code class="filename">devtool</code>.
            When you use <code class="filename">devtool add</code>, a recipe is
            automatically created.
            When you use <code class="filename">devtool modify</code>, the specified
            existing recipe is used in order to determine where to get the
            source code and how to patch it.
            In both cases, an environment is set up so that when you build the
            recipe a source tree that is under your control is used in order to
            allow you to make changes to the source as desired.
            By default, new recipes and the source go into a "workspace"
            directory under the SDK.
        </p><p>
            The remainder of this section presents the
            <code class="filename">devtool add</code>,
            <code class="filename">devtool modify</code>, and
            <code class="filename">devtool upgrade</code> workflows.
        </p><div class="section" title="2.4.1.Â Use devtool add to Add an Application"><div class="titlepage"><div><div><h3 class="title" id="sdk-use-devtool-to-add-an-application">2.4.1.&nbsp;Use <code class="filename">devtool add</code> to Add an Application<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-use-devtool-to-add-an-application">Â¶</a></span></h3></div></div></div><p>
                The <code class="filename">devtool add</code> command generates
                a new recipe based on existing source code.
                This command takes advantage of the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#devtool-the-workspace-layer-structure" target="_top">workspace</a>
                layer that many <code class="filename">devtool</code> commands
                use.
                The command is flexible enough to allow you to extract source
                code into both the workspace or a separate local Git repository
                and to use existing code that does not need to be extracted.
            </p><p>
                Depending on your particular scenario, the arguments and options
                you use with <code class="filename">devtool add</code> form different
                combinations.
                The following diagram shows common development flows
                you would use with the <code class="filename">devtool add</code>
                command:
            </p><p>
                <img src="./Yocto Project Application Development and the Extensible Software Development Kit (eSDK)_files/sdk-devtool-add-flow.png" align="middle">
            </p><p>
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="emphasis"><em>Generating the New Recipe</em></span>:
                        The top part of the flow shows three scenarios by which
                        you could use <code class="filename">devtool add</code> to
                        generate a recipe based on existing source code.</p><p>In a shared development environment, it is
                        typical for other developers to be responsible for
                        various areas of source code.
                        As a developer, you are probably interested in using
                        that source code as part of your development within
                        the Yocto Project.
                        All you need is access to the code, a recipe, and a
                        controlled area in which to do your work.</p><p>Within the diagram, three possible scenarios
                        feed into the <code class="filename">devtool add</code> workflow:
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                                <span class="emphasis"><em>Left</em></span>:
                                The left scenario in the figure represents a
                                common situation where the source code does not
                                exist locally and needs to be extracted.
                                In this situation, the source code is extracted
                                to the default workspace - you do not
                                want the files in some specific location
                                outside of the workspace.
                                Thus, everything you need will be located in
                                the workspace:
                                </p><pre class="literallayout">     $ devtool add <em class="replaceable"><code>recipe fetchuri</code></em>
                                </pre><p>
                                With this command, <code class="filename">devtool</code>
                                extracts the upstream source files into a local
                                Git repository within the
                                <code class="filename">sources</code> folder.
                                The command then creates a recipe named
                                <em class="replaceable"><code>recipe</code></em> and a
                                corresponding append file in the workspace.
                                If you do not provide
                                <em class="replaceable"><code>recipe</code></em>, the command
                                makes an attempt to determine the recipe name.
                                </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>Middle</em></span>:
                                The middle scenario in the figure also
                                represents a situation where the source code
                                does not exist locally.
                                In this case, the code is again upstream
                                and needs to be extracted to some
                                local area - this time outside of the default
                                workspace.
                                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                                    If required, <code class="filename">devtool</code>
                                    always creates
                                    a Git repository locally during the
                                    extraction.
                                </div><p>
                                Furthermore, the first positional argument
                                <em class="replaceable"><code>srctree</code></em> in this
                                case identifies where the
                                <code class="filename">devtool add</code> command
                                will locate the extracted code outside of the
                                workspace.
                                You need to specify an empty directory:
                                </p><pre class="literallayout">     $ devtool add <em class="replaceable"><code>recipe srctree fetchuri</code></em>
                                </pre><p>
                                In summary, the source code is pulled from
                                <em class="replaceable"><code>fetchuri</code></em> and
                                extracted into the location defined by
                                <em class="replaceable"><code>srctree</code></em> as a local
                                Git repository.</p><p>Within workspace,
                                <code class="filename">devtool</code> creates a
                                recipe named <em class="replaceable"><code>recipe</code></em>
                                along with an associated append file.
                                </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>Right</em></span>:
                                The right scenario in the figure represents a
                                situation where the
                                <em class="replaceable"><code>srctree</code></em> has been
                                previously prepared outside of the
                                <code class="filename">devtool</code> workspace.</p><p>The following command provides a new
                                recipe name and identifies the existing source
                                tree location:
                                </p><pre class="literallayout">     $ devtool add <em class="replaceable"><code>recipe srctree</code></em>
                                </pre><p>
                                The command examines the source code and
                                creates a recipe named
                                <em class="replaceable"><code>recipe</code></em> for the code
                                and places the recipe into the workspace.
                                </p><p>Because the extracted source code already
                                exists, <code class="filename">devtool</code> does not
                                try to relocate the source code into the
                                workspace - only the new recipe is placed
                                in the workspace.</p><p>Aside from a recipe folder, the command
                                also creates an associated append folder and
                                places an initial
                                <code class="filename">*.bbappend</code> file within.
                                </p></li></ul></div><p>
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Edit the Recipe</em></span>:
                        You can use <code class="filename">devtool edit-recipe</code>
                        to open up the editor as defined by the
                        <code class="filename">$EDITOR</code> environment variable
                        and modify the file:
                        </p><pre class="literallayout">     $ devtool edit-recipe <em class="replaceable"><code>recipe</code></em>
                        </pre><p>
                        From within the editor, you can make modifications to
                        the recipe that take affect when you build it later.
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Build the Recipe or Rebuild the Image</em></span>:
                        The next step you take depends on what you are going
                        to do with the new code.</p><p>If you need to eventually move the build output
                        to the target hardware, use the following
                        <code class="filename">devtool</code> command:
                        </p><pre class="literallayout">     $ devtool build <em class="replaceable"><code>recipe</code></em>
                        </pre><p>On the other hand, if you want an image to
                        contain the recipe's packages from the workspace
                        for immediate deployment onto a device (e.g. for
                        testing purposes), you can use
                        the <code class="filename">devtool build-image</code> command:
                        </p><pre class="literallayout">     $ devtool build-image <em class="replaceable"><code>image</code></em>
                        </pre><p>
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Deploy the Build Output</em></span>:
                        When you use the <code class="filename">devtool build</code>
                        command to build out your recipe, you probably want to
                        see if the resulting build output works as expected
                        on the target hardware.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            This step assumes you have a previously built
                            image that is already either running in QEMU or
                            is running on actual hardware.
                            Also, it is assumed that for deployment of the
                            image to the target, SSH is installed in the image
                            and, if the image is running on real hardware,
                            you have network access to and from your
                            development machine.
                        </div><p>
                        You can deploy your build output to that target
                        hardware by using the
                        <code class="filename">devtool deploy-target</code> command:
                        </p><pre class="literallayout">     $ devtool deploy-target <em class="replaceable"><code>recipe target</code></em>
                        </pre><p>
                        The <em class="replaceable"><code>target</code></em> is a live target
                        machine running as an SSH server.</p><p>You can, of course, also deploy the image you
                        build to actual hardware by using the
                        <code class="filename">devtool build-image</code> command.
                        However, <code class="filename">devtool</code> does not provide
                        a specific command that allows you to deploy the
                        image to actual hardware.
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Finish Your Work With the Recipe</em></span>:
                        The <code class="filename">devtool finish</code> command creates
                        any patches corresponding to commits in the local
                        Git repository, moves the new recipe to a more permanent
                        layer, and then resets the recipe so that the recipe is
                        built normally rather than from the workspace.
                        </p><pre class="literallayout">     $ devtool finish <em class="replaceable"><code>recipe layer</code></em>
                        </pre><p>
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            Any changes you want to turn into patches must be
                            committed to the Git repository in the source tree.
                        </div><p>As mentioned, the
                        <code class="filename">devtool finish</code> command moves the
                        final recipe to its permanent layer.
                        </p><p>As a final process of the
                        <code class="filename">devtool finish</code> command, the state
                        of the standard layers and the upstream source is
                        restored so that you can build the recipe from those
                        areas rather than the workspace.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            You can use the <code class="filename">devtool reset</code>
                            command to put things back should you decide you
                            do not want to proceed with your work.
                            If you do use this command, realize that the source
                            tree is preserved.
                        </div><p>
                        </p></li></ol></div><p>
            </p></div><div class="section" title="2.4.2.Â Use devtool modify to Modify the Source of an Existing Component"><div class="titlepage"><div><div><h3 class="title" id="sdk-devtool-use-devtool-modify-to-modify-the-source-of-an-existing-component">2.4.2.&nbsp;Use <code class="filename">devtool modify</code> to Modify the Source of an Existing Component<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-devtool-use-devtool-modify-to-modify-the-source-of-an-existing-component">Â¶</a></span></h3></div></div></div><p>
                The <code class="filename">devtool modify</code> command prepares the
                way to work on existing code that already has a local recipe in
                place that is used to build the software.
                The command is flexible enough to allow you to extract code
                from an upstream source, specify the existing recipe, and
                keep track of and gather any patch files from other developers
                that are associated with the code.
            </p><p>
                Depending on your particular scenario, the arguments and options
                you use with <code class="filename">devtool modify</code> form different
                combinations.
                The following diagram shows common development flows for the
                <code class="filename">devtool modify</code> command:
            </p><p>
                <img src="./Yocto Project Application Development and the Extensible Software Development Kit (eSDK)_files/sdk-devtool-modify-flow.png" align="middle">
            </p><p>
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                        <span class="emphasis"><em>Preparing to Modify the Code</em></span>:
                        The top part of the flow shows three scenarios by which
                        you could use <code class="filename">devtool modify</code> to
                        prepare to work on source files.
                        Each scenario assumes the following:
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                                The recipe exists locally in a layer external
                                to the <code class="filename">devtool</code> workspace.
                                </p></li><li class="listitem"><p>
                                The source files exist either upstream in an
                                un-extracted state or locally in a previously
                                extracted state.
                                </p></li></ul></div><p>
                        The typical situation is where another developer has
                        created a layer for use with the Yocto Project and
                        their recipe already resides in that layer.
                        Furthermore, their source code is readily available
                        either upstream or locally.
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                                <span class="emphasis"><em>Left</em></span>:
                                The left scenario in the figure represents a
                                common situation where the source code does
                                not exist locally and it needs to be extracted
                                from an upstream source.
                                In this situation, the source is extracted
                                into the default <code class="filename">devtool</code>
                                workspace location.
                                The recipe, in this scenario, is in its own
                                layer outside the workspace
                                (i.e.
                                <code class="filename">meta-</code><em class="replaceable"><code>layername</code></em>).
                                </p><p>The following command identifies the
                                recipe and, by default, extracts the source
                                files:
                                </p><pre class="literallayout">     $ devtool modify <em class="replaceable"><code>recipe</code></em>
                                </pre><p>
                                Once <code class="filename">devtool</code>locates the
                                recipe, <code class="filename">devtool</code> uses the
                                recipe's
                                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                                statements to locate the source code and any
                                local patch files from other developers.</p><p>With this scenario, no
                                <em class="replaceable"><code>srctree</code></em> argument
                                exists.
                                Consequently, the default behavior of the
                                <code class="filename">devtool modify</code> command is
                                to extract the source files pointed to by the
                                <code class="filename">SRC_URI</code> statements into a
                                local Git structure.
                                Furthermore, the location for the extracted
                                source is the default area within the
                                <code class="filename">devtool</code> workspace.
                                The result is that the command sets up both
                                the source code and an append file within the
                                workspace while the recipe remains in its
                                original location.</p><p>Additionally, if you have any non-patch
                                local files (i.e. files referred to with
                                <code class="filename">file://</code> entries in
                                <code class="filename">SRC_URI</code> statement excluding
                                <code class="filename">*.patch/</code> or
                                <code class="filename">*.diff</code>), these files are
                                copied to an
                                <code class="filename">oe-local-files</code> folder
                                under the newly created source tree.
                                Copying the files here gives you a convenient
                                area from which you can modify the files.
                                Any changes or additions you make to those
                                files are incorporated into the build the next
                                time you build the software just as are other
                                changes you might have made to the source.
                                </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>Middle</em></span>:
                                The middle scenario in the figure represents a
                                situation where the source code also does not
                                exist locally.
                                In this case, the code is again upstream
                                and needs to be extracted to some
                                local area as a Git repository.
                                The recipe, in this scenario, is again local
                                and in its own layer outside the workspace.
                                </p><p>The following command tells
                                <code class="filename">devtool</code> the recipe with
                                which to work and, in this case, identifies a
                                local area for the extracted source files that
                                exists outside of the default
                                <code class="filename">devtool</code> workspace:
                                </p><pre class="literallayout">     $ devtool modify <em class="replaceable"><code>recipe srctree</code></em>
                                </pre><p>
                                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                                    You cannot provide a URL for
                                    <em class="replaceable"><code>srctree</code></em> using
                                    the <code class="filename">devtool</code> command.
                                </div><p>
                                As with all extractions, the command uses
                                the recipe's <code class="filename">SRC_URI</code>
                                statements to locate the source files and any
                                associated patch files.
                                Non-patch files are copied to an
                                <code class="filename">oe-local-files</code> folder
                                under the newly created source tree.</p><p>Once the files are located, the command
                                by default extracts them into
                                <em class="replaceable"><code>srctree</code></em>.</p><p>Within workspace,
                                <code class="filename">devtool</code> creates an append
                                file for the recipe.
                                The recipe remains in its original location but
                                the source files are extracted to the location
                                you provide with
                                <em class="replaceable"><code>srctree</code></em>.
                                </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>Right</em></span>:
                                The right scenario in the figure represents a
                                situation where the source tree
                                (<em class="replaceable"><code>srctree</code></em>) already
                                exists locally as a previously extracted Git
                                structure outside of the
                                <code class="filename">devtool</code> workspace.
                                In this example, the recipe also exists
                                elsewhere locally in its own layer.
                                </p><p>The following command tells
                                <code class="filename">devtool</code> the recipe
                                with which to work, uses the "-n" option to
                                indicate source does not need to be extracted,
                                and uses <em class="replaceable"><code>srctree</code></em> to
                                point to the previously extracted source files:
                                </p><pre class="literallayout">     $ devtool modify -n <em class="replaceable"><code>recipe srctree</code></em>
                                </pre><p>
                                </p><p>If an <code class="filename">oe-local-files</code>
                                subdirectory happens to exist and it contains
                                non-patch files, the files are used.
                                However, if the subdirectory does not exist and
                                you run the <code class="filename">devtool finish</code>
                                command, any non-patch files that might exist
                                next to the recipe are removed because it
                                appears to <code class="filename">devtool</code> that
                                you have deleted those files.</p><p>Once the
                                <code class="filename">devtool modify</code> command
                                finishes, it creates only an append file for
                                the recipe in the <code class="filename">devtool</code>
                                workspace.
                                The recipe and the source code remain in their
                                original locations.
                                </p></li></ul></div><p>
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Edit the Source</em></span>:
                        Once you have used the
                        <code class="filename">devtool modify</code> command, you are
                        free to make changes to the source files.
                        You can use any editor you like to make and save
                        your source code modifications.
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Build the Recipe or Rebuild the Image</em></span>:
                        The next step you take depends on what you are going
                        to do with the new code.</p><p>If you need to eventually move the build output
                        to the target hardware, use the following
                        <code class="filename">devtool</code> command:
                        </p><pre class="literallayout">     $ devtool build <em class="replaceable"><code>recipe</code></em>
                        </pre><p>On the other hand, if you want an image to
                        contain the recipe's packages from the workspace
                        for immediate deployment onto a device (e.g. for
                        testing purposes), you can use
                        the <code class="filename">devtool build-image</code> command:
                        </p><pre class="literallayout">     $ devtool build-image <em class="replaceable"><code>image</code></em>
                        </pre><p>
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Deploy the Build Output</em></span>:
                        When you use the <code class="filename">devtool build</code>
                        command to build out your recipe, you probably want to
                        see if the resulting build output works as expected
                        on target hardware.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            This step assumes you have a previously built
                            image that is already either running in QEMU or
                            running on actual hardware.
                            Also, it is assumed that for deployment of the image
                            to the target, SSH is installed in the image and if
                            the image is running on real hardware that you have
                            network access to and from your development machine.
                        </div><p>
                        You can deploy your build output to that target
                        hardware by using the
                        <code class="filename">devtool deploy-target</code> command:
                        </p><pre class="literallayout">     $ devtool deploy-target <em class="replaceable"><code>recipe target</code></em>
                        </pre><p>
                        The <em class="replaceable"><code>target</code></em> is a live target
                        machine running as an SSH server.</p><p>You can, of course, use other methods to deploy
                        the image you built using the
                        <code class="filename">devtool build-image</code> command to
                        actual hardware.
                        <code class="filename">devtool</code> does not provide
                        a specific command to deploy the image to actual
                        hardware.
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Finish Your Work With the Recipe</em></span>:
                        The <code class="filename">devtool finish</code> command creates
                        any patches corresponding to commits in the local
                        Git repository, updates the recipe to point to them
                        (or creates a <code class="filename">.bbappend</code> file to do
                        so, depending on the specified destination layer), and
                        then resets the recipe so that the recipe is built
                        normally rather than from the workspace.
                        </p><pre class="literallayout">     $ devtool finish <em class="replaceable"><code>recipe layer</code></em>
                        </pre><p>
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            Any changes you want to turn into patches must be
                            staged and committed within the local Git
                            repository before you use the
                            <code class="filename">devtool finish</code> command.
                        </div><p>Because there is no need to move the recipe,
                        <code class="filename">devtool finish</code> either updates the
                        original recipe in the original layer or the command
                        creates a <code class="filename">.bbappend</code> file in a
                        different layer as provided by
                        <em class="replaceable"><code>layer</code></em>.
                        Any work you did in the
                        <code class="filename">oe-local-files</code> directory is
                        preserved in the original files next to the recipe
                        during the <code class="filename">devtool finish</code>
                        command.</p><p>As a final process of the
                        <code class="filename">devtool finish</code> command, the state
                        of the standard layers and the upstream source is
                        restored so that you can build the recipe from those
                        areas rather than from the workspace.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            You can use the <code class="filename">devtool reset</code>
                            command to put things back should you decide you
                            do not want to proceed with your work.
                            If you do use this command, realize that the source
                            tree is preserved.
                        </div><p>
                        </p></li></ol></div><p>
            </p></div><div class="section" title="2.4.3.Â Use devtool upgrade to Create a Version of the Recipe that Supports a Newer Version of the Software"><div class="titlepage"><div><div><h3 class="title" id="sdk-devtool-use-devtool-upgrade-to-create-a-version-of-the-recipe-that-supports-a-newer-version-of-the-software">2.4.3.&nbsp;Use <code class="filename">devtool upgrade</code> to Create a Version of the Recipe that Supports a Newer Version of the Software<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-devtool-use-devtool-upgrade-to-create-a-version-of-the-recipe-that-supports-a-newer-version-of-the-software">Â¶</a></span></h3></div></div></div><p>
                The <code class="filename">devtool upgrade</code> command upgrades
                an existing recipe to that of a more up-to-date version
                found upstream.
                Throughout the life of software, recipes continually undergo
                version upgrades by their upstream publishers.
                You can use the <code class="filename">devtool upgrade</code>
                workflow to make sure your recipes you are using for builds
                are up-to-date with their upstream counterparts.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    Several methods exist by which you can upgrade recipes -
                    <code class="filename">devtool upgrade</code> happens to be one.
                    You can read about all the methods by which you can
                    upgrade recipes in the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/dev-manual/dev-manual.html#gs-upgrading-recipes" target="_top">Upgrading Recipes</a>"
                    section of the Yocto Project Development Tasks Manual.
                </div><p>
            </p><p>
                The <code class="filename">devtool upgrade</code> command is flexible
                enough to allow you to specify source code revision and
                versioning schemes, extract code into or out of the
                <code class="filename">devtool</code>
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#devtool-the-workspace-layer-structure" target="_top">workspace</a>,
                and work with any source file forms that the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/bitbake-user-manual/bitbake-user-manual.html#bb-fetchers" target="_top">fetchers</a>
                support.
            </p><p>
                The following diagram shows the common development flow
                used with the <code class="filename">devtool upgrade</code> command:
            </p><p>
                <img src="./Yocto Project Application Development and the Extensible Software Development Kit (eSDK)_files/sdk-devtool-upgrade-flow.png" align="middle">
            </p><p>
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                        <span class="emphasis"><em>Initiate the Upgrade</em></span>:
                        The top part of the flow shows the typical scenario by
                        which you use the <code class="filename">devtool upgrade</code>
                        command.
                        The following conditions exist:
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                                The recipe exists in a local layer external
                                to the <code class="filename">devtool</code> workspace.
                                </p></li><li class="listitem"><p>
                                The source files for the new release
                                exist in the same location pointed to by
                                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                                in the recipe (e.g. a tarball with the new
                                version number in the name, or as a different
                                revision in the upstream Git repository).
                                </p></li></ul></div><p>
                        A common situation is where third-party software has
                        undergone a revision so that it has been upgraded.
                        The recipe you have access to is likely in your own
                        layer.
                        Thus, you need to upgrade the recipe to use the
                        newer version of the software:
                        </p><pre class="literallayout">     $ devtool upgrade -V <em class="replaceable"><code>version recipe</code></em>
                        </pre><p>
                        By default, the <code class="filename">devtool upgrade</code>
                        command extracts source code into the
                        <code class="filename">sources</code> directory in the
                        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#devtool-the-workspace-layer-structure" target="_top">workspace</a>.
                        If you want the code extracted to any other location,
                        you need to provide the
                        <em class="replaceable"><code>srctree</code></em> positional argument
                        with the command as follows:
                        </p><pre class="literallayout">     $ devtool upgrade -V <em class="replaceable"><code>version recipe srctree</code></em>
                        </pre><p>
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            In this example, the "-V" option specifies the new
                            version.
                            If you don't use "-V", the command upgrades the
                            recipe to the latest version.
                        </div><p>
                        If the source files pointed to by the
                        <code class="filename">SRC_URI</code> statement in the recipe
                        are in a Git repository, you must provide the "-S"
                        option and specify a revision for the software.</p><p>Once <code class="filename">devtool</code> locates the
                        recipe, it uses the <code class="filename">SRC_URI</code>
                        variable to locate the source code and any local patch
                        files from other developers.
                        The result is that the command sets up the source
                        code, the new version of the recipe, and an append file
                        all within the workspace.</p><p>Additionally, if you have any non-patch
                        local files (i.e. files referred to with
                        <code class="filename">file://</code> entries in
                        <code class="filename">SRC_URI</code> statement excluding
                        <code class="filename">*.patch/</code> or
                        <code class="filename">*.diff</code>), these files are
                        copied to an
                        <code class="filename">oe-local-files</code> folder
                        under the newly created source tree.
                        Copying the files here gives you a convenient
                        area from which you can modify the files.
                        Any changes or additions you make to those
                        files are incorporated into the build the next
                        time you build the software just as are other
                        changes you might have made to the source.
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Resolve any Conflicts created by the Upgrade</em></span>:
                        Conflicts could exist due to the software being
                        upgraded to a new version.
                        Conflicts occur if your recipe specifies some patch
                        files in <code class="filename">SRC_URI</code> that conflict
                        with changes made in the new version of the software.
                        For such cases, you need to resolve the conflicts
                        by editing the source and following the normal
                        <code class="filename">git rebase</code> conflict resolution
                        process.</p><p>Before moving onto the next step, be sure to
                        resolve any such conflicts created through use of a
                        newer or different version of the software.
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Build the Recipe or Rebuild the Image</em></span>:
                        The next step you take depends on what you are going
                        to do with the new code.</p><p>If you need to eventually move the build output
                        to the target hardware, use the following
                        <code class="filename">devtool</code> command:
                        </p><pre class="literallayout">     $ devtool build <em class="replaceable"><code>recipe</code></em>
                        </pre><p>On the other hand, if you want an image to
                        contain the recipe's packages from the workspace
                        for immediate deployment onto a device (e.g. for
                        testing purposes), you can use
                        the <code class="filename">devtool build-image</code> command:
                        </p><pre class="literallayout">     $ devtool build-image <em class="replaceable"><code>image</code></em>
                        </pre><p>
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Deploy the Build Output</em></span>:
                        When you use the <code class="filename">devtool build</code>
                        command or <code class="filename">bitbake</code> to build
                        your recipe, you probably want to see if the resulting
                        build output works as expected on target hardware.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            This step assumes you have a previously built
                            image that is already either running in QEMU or
                            running on actual hardware.
                            Also, it is assumed that for deployment of the
                            image to the target, SSH is installed in the image
                            and if the image is running on real hardware that
                            you have network access to and from your
                            development machine.
                        </div><p>
                        You can deploy your build output to that target
                        hardware by using the
                        <code class="filename">devtool deploy-target</code> command:
                        </p><pre class="literallayout">     $ devtool deploy-target <em class="replaceable"><code>recipe target</code></em>
                        </pre><p>
                        The <em class="replaceable"><code>target</code></em> is a live target
                        machine running as an SSH server.</p><p>You can, of course, also deploy the image you
                        build using the
                        <code class="filename">devtool build-image</code> command
                        to actual hardware.
                        However, <code class="filename">devtool</code> does not provide
                        a specific command that allows you to do this.
                        </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>Finish Your Work With the Recipe</em></span>:
                        The <code class="filename">devtool finish</code> command creates
                        any patches corresponding to commits in the local
                        Git repository, moves the new recipe to a more
                        permanent layer, and then resets the recipe so that
                        the recipe is built normally rather than from the
                        workspace.</p><p>Any work you did in the
                        <code class="filename">oe-local-files</code> directory is
                        preserved in the original files next to the recipe
                        during the <code class="filename">devtool finish</code>
                        command.</p><p>
                        If you specify a destination layer that is the same as
                        the original source, then the old version of the
                        recipe and associated files are removed prior to
                        adding the new version.
                        </p><pre class="literallayout">     $ devtool finish <em class="replaceable"><code>recipe layer</code></em>
                        </pre><p>
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            Any changes you want to turn into patches must be
                            committed to the Git repository in the source tree.
                        </div><p>As a final process of the
                        <code class="filename">devtool finish</code> command, the state
                        of the standard layers and the upstream source is
                        restored so that you can build the recipe from those
                        areas rather than the workspace.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            You can use the <code class="filename">devtool reset</code>
                            command to put things back should you decide you
                            do not want to proceed with your work.
                            If you do use this command, realize that the source
                            tree is preserved.
                        </div><p>
                        </p></li></ol></div><p>
            </p></div></div><div class="section" title="2.5.Â A Closer Look at devtool add"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-a-closer-look-at-devtool-add">2.5.&nbsp;A Closer Look at <code class="filename">devtool add</code><span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-a-closer-look-at-devtool-add">Â¶</a></span></h2></div></div></div><p>
            The <code class="filename">devtool add</code> command automatically creates
            a recipe based on the source tree you provide with the command.
            Currently, the command has support for the following:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    Autotools (<code class="filename">autoconf</code> and
                    <code class="filename">automake</code>)
                    </p></li><li class="listitem"><p>
                    CMake
                    </p></li><li class="listitem"><p>
                    Scons
                    </p></li><li class="listitem"><p>
                    <code class="filename">qmake</code>
                    </p></li><li class="listitem"><p>
                    Plain <code class="filename">Makefile</code>
                    </p></li><li class="listitem"><p>
                    Out-of-tree kernel module
                    </p></li><li class="listitem"><p>
                    Binary package (i.e. "-b" option)
                    </p></li><li class="listitem"><p>
                    Node.js module
                    </p></li><li class="listitem"><p>
                    Python modules that use <code class="filename">setuptools</code>
                    or <code class="filename">distutils</code>
                    </p></li></ul></div><p>
        </p><p>
            Apart from binary packages, the determination of how a source tree
            should be treated is automatic based on the files present within
            that source tree.
            For example, if a <code class="filename">CMakeLists.txt</code> file is found,
            then the source tree is assumed to be using
            CMake and is treated accordingly.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                In most cases, you need to edit the automatically generated
                recipe in order to make it build properly.
                Typically, you would go through several edit and build cycles
                until the recipe successfully builds.
                Once the recipe builds, you could use possible further
                iterations to test the recipe on the target device.
            </div><p>
        </p><p>
            The remainder of this section covers specifics regarding how parts
            of the recipe are generated.
        </p><div class="section" title="2.5.1.Â Name and Version"><div class="titlepage"><div><div><h3 class="title" id="sdk-name-and-version">2.5.1.&nbsp;Name and Version<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-name-and-version">Â¶</a></span></h3></div></div></div><p>
                If you do not specify a name and version on the command
                line, <code class="filename">devtool add</code> uses various metadata
                within the source tree in an attempt to determine
                the name and version of the software being built.
                Based on what the tool determines, <code class="filename">devtool</code>
                sets the name of the created recipe file accordingly.
            </p><p>
                If <code class="filename">devtool</code> cannot determine the name and
                version, the command prints an error.
                For such cases, you must re-run the command and provide
                the name and version, just the name, or just the version as
                part of the command line.
            </p><p>
                Sometimes the name or version determined from the source tree
                might be incorrect.
                For such a case, you must reset the recipe:
                </p><pre class="literallayout">     $ devtool reset -n <em class="replaceable"><code>recipename</code></em>
                </pre><p>
                After running the <code class="filename">devtool reset</code> command,
                you need to run <code class="filename">devtool add</code> again and
                provide the name or the version.
            </p></div><div class="section" title="2.5.2.Â Dependency Detection and Mapping"><div class="titlepage"><div><div><h3 class="title" id="sdk-dependency-detection-and-mapping">2.5.2.&nbsp;Dependency Detection and Mapping<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-dependency-detection-and-mapping">Â¶</a></span></h3></div></div></div><p>
                The <code class="filename">devtool add</code> command attempts to
                detect build-time dependencies and map them to other recipes
                in the system.
                During this mapping, the command fills in the names of those
                recipes as part of the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-DEPENDS" target="_top"><code class="filename">DEPENDS</code></a>
                variable within the recipe.
                If a dependency cannot be mapped, <code class="filename">devtool</code>
                places a comment in the recipe indicating such.
                The inability to map a dependency can result from naming not
                being recognized or because the dependency simply is not
                available.
                For cases where the dependency is not available, you must use
                the <code class="filename">devtool add</code> command to add an
                additional recipe that satisfies the dependency.
                Once you add that recipe, you need to update the
                <code class="filename">DEPENDS</code> variable in the original recipe
                to include the new recipe.
            </p><p>
                If you need to add runtime dependencies, you can do so by
                adding the following to your recipe:
                </p><pre class="literallayout">     RDEPENDS_${PN} += "<em class="replaceable"><code>dependency1 dependency2 ...</code></em>"
                </pre><p>
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    The <code class="filename">devtool add</code> command often cannot
                    distinguish between mandatory and optional dependencies.
                    Consequently, some of the detected dependencies might
                    in fact be optional.
                    When in doubt, consult the documentation or the configure
                    script for the software the recipe is building for further
                    details.
                    In some cases, you might find you can substitute the
                    dependency with an option that disables the associated
                    functionality passed to the configure script.
                </div><p>
            </p></div><div class="section" title="2.5.3.Â License Detection"><div class="titlepage"><div><div><h3 class="title" id="sdk-license-detection">2.5.3.&nbsp;License Detection<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-license-detection">Â¶</a></span></h3></div></div></div><p>
                The <code class="filename">devtool add</code> command attempts to
                determine if the software you are adding is able to be
                distributed under a common, open-source license.
                If so, the command sets the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-LICENSE" target="_top"><code class="filename">LICENSE</code></a>
                value accordingly.
                You should double-check the value added by the command against
                the documentation or source files for the software you are
                building and, if necessary, update that
                <code class="filename">LICENSE</code> value.
            </p><p>
                The <code class="filename">devtool add</code> command also sets the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-LIC_FILES_CHKSUM" target="_top"><code class="filename">LIC_FILES_CHKSUM</code></a>
                value to point to all files that appear to be license-related.
                Realize that license statements often appear in comments at
                the top of source files or within the documentation.
                In such cases, the command does not recognize those license
                statements.
                Consequently, you might need to amend the
                <code class="filename">LIC_FILES_CHKSUM</code> variable to point to one
                or more of those comments if present.
                Setting <code class="filename">LIC_FILES_CHKSUM</code> is particularly
                important for third-party software.
                The mechanism attempts to ensure correct licensing should you
                upgrade the recipe to a newer upstream version in future.
                Any change in licensing is detected and you receive an error
                prompting you to check the license text again.
            </p><p>
                If the <code class="filename">devtool add</code> command cannot
                determine licensing information, <code class="filename">devtool</code>
                sets the <code class="filename">LICENSE</code> value to "CLOSED" and
                leaves the <code class="filename">LIC_FILES_CHKSUM</code> value unset.
                This behavior allows you to continue with development even
                though the settings are unlikely to be correct in all cases.
                You should check the documentation or source files for the
                software you are building to determine the actual license.
            </p></div><div class="section" title="2.5.4.Â Adding Makefile-Only Software"><div class="titlepage"><div><div><h3 class="title" id="sdk-adding-makefile-only-software">2.5.4.&nbsp;Adding Makefile-Only Software<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-makefile-only-software">Â¶</a></span></h3></div></div></div><p>
                The use of Make by itself is very common in both proprietary
                and open-source software.
                Unfortunately, Makefiles are often not written with
                cross-compilation in mind.
                Thus, <code class="filename">devtool add</code> often cannot do very
                much to ensure that these Makefiles build correctly.
                It is very common, for example, to explicitly call
                <code class="filename">gcc</code> instead of using the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-CC" target="_top"><code class="filename">CC</code></a>
                variable.
                Usually, in a cross-compilation environment,
                <code class="filename">gcc</code> is the compiler for the build host
                and the cross-compiler is named something similar to
                <code class="filename">arm-poky-linux-gnueabi-gcc</code> and might
                require arguments (e.g. to point to the associated sysroot
                for the target machine).
            </p><p>
                When writing a recipe for Makefile-only software, keep the
                following in mind:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        You probably need to patch the Makefile to use
                        variables instead of hardcoding tools within the
                        toolchain such as <code class="filename">gcc</code> and
                        <code class="filename">g++</code>.
                        </p></li><li class="listitem"><p>
                        The environment in which Make runs is set up with
                        various standard variables for compilation (e.g.
                        <code class="filename">CC</code>, <code class="filename">CXX</code>, and
                        so forth) in a similar manner to the environment set
                        up by the SDK's environment setup script.
                        One easy way to see these variables is to run the
                        <code class="filename">devtool build</code> command on the
                        recipe and then look in
                        <code class="filename">oe-logs/run.do_compile</code>.
                        Towards the top of this file, a list of environment
                        variables exists that are being set.
                        You can take advantage of these variables within the
                        Makefile.
                        </p></li><li class="listitem"><p>
                        If the Makefile sets a default for a variable using "=",
                        that default overrides the value set in the environment,
                        which is usually not desirable.
                        For this case, you can either patch the Makefile
                        so it sets the default using the "?=" operator, or
                        you can alternatively force the value on the
                        <code class="filename">make</code> command line.
                        To force the value on the command line, add the
                        variable setting to
                        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-EXTRA_OEMAKE" target="_top"><code class="filename">EXTRA_OEMAKE</code></a>
                        or
                        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-PACKAGECONFIG_CONFARGS" target="_top"><code class="filename">PACKAGECONFIG_CONFARGS</code></a>
                        within the recipe.
                        Here is an example using <code class="filename">EXTRA_OEMAKE</code>:
                        </p><pre class="literallayout">     EXTRA_OEMAKE += "'CC=${CC}' 'CXX=${CXX}'"
                        </pre><p>
                        In the above example, single quotes are used around the
                        variable settings as the values are likely to contain
                        spaces because required default options are passed to
                        the compiler.
                        </p></li><li class="listitem"><p>
                        Hardcoding paths inside Makefiles is often problematic
                        in a cross-compilation environment.
                        This is particularly true because those hardcoded paths
                        often point to locations on the build host and thus
                        will either be read-only or will introduce
                        contamination into the cross-compilation because they
                        are specific to the build host rather than the target.
                        Patching the Makefile to use prefix variables or other
                        path variables is usually the way to handle this
                        situation.
                        </p></li><li class="listitem"><p>
                        Sometimes a Makefile runs target-specific commands such
                        as <code class="filename">ldconfig</code>.
                        For such cases, you might be able to apply patches that
                        remove these commands from the Makefile.
                        </p></li></ul></div><p>
            </p></div><div class="section" title="2.5.5.Â Adding Native Tools"><div class="titlepage"><div><div><h3 class="title" id="sdk-adding-native-tools">2.5.5.&nbsp;Adding Native Tools<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-native-tools">Â¶</a></span></h3></div></div></div><p>
                Often, you need to build additional tools that run on the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#hardware-build-system-term" target="_top">build host</a>
                as opposed to the target.
                You should indicate this requirement by using one of the
                following methods when you run
                <code class="filename">devtool add</code>:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        Specify the name of the recipe such that it ends
                        with "-native".
                        Specifying the name like this produces a recipe that
                        only builds for the build host.
                        </p></li><li class="listitem"><p>
                        Specify the "ââalso-native" option with the
                        <code class="filename">devtool add</code> command.
                        Specifying this option creates a recipe file that still
                        builds for the target but also creates a variant with
                        a "-native" suffix that builds for the build host.
                        </p></li></ul></div><p>
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    If you need to add a tool that is shipped as part of a
                    source tree that builds code for the target, you can
                    typically accomplish this by building the native and target
                    parts separately rather than within the same compilation
                    process.
                    Realize though that with the "ââalso-native"
                    option, you can add the tool using just one recipe file.
                </div><p>
            </p></div><div class="section" title="2.5.6.Â Adding Node.js Modules"><div class="titlepage"><div><div><h3 class="title" id="sdk-adding-node-js-modules">2.5.6.&nbsp;Adding Node.js Modules<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-node-js-modules">Â¶</a></span></h3></div></div></div><p>
                You can use the <code class="filename">devtool add</code> command two
                different ways to add Node.js modules: 1) Through
                <code class="filename">npm</code> and, 2) from a repository or local
                source.
            </p><p>
                Use the following form to add Node.js modules through
                <code class="filename">npm</code>:
                </p><pre class="literallayout">     $ devtool add "npm://registry.npmjs.org;name=forever;version=0.15.1"
                </pre><p>
                The name and version parameters are mandatory.
                Lockdown and shrinkwrap files are generated and pointed to by
                the recipe in order to freeze the version that is fetched for
                the dependencies according to the first time.
                This also saves checksums that are verified on future fetches.
                Together, these behaviors ensure the reproducibility and
                integrity of the build.
                </p><div class="note" title="Notes" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Notes</h3><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            You must use quotes around the URL.
                            The <code class="filename">devtool add</code> does not require
                            the quotes, but the shell considers ";" as a splitter
                            between multiple commands.
                            Thus, without the quotes,
                            <code class="filename">devtool add</code> does not receive the
                            other parts, which results in several "command not
                            found" errors.
                            </p></li><li class="listitem"><p>
                            In order to support adding Node.js modules, a
                            <code class="filename">nodejs</code> recipe must be part
                            of your SDK.
                            </p></li></ul></div></div><p>
            </p><p>
                As mentioned earlier, you can also add Node.js modules
                directly from a repository or local source tree.
                To add modules this way, use <code class="filename">devtool add</code>
                in the following form:
                </p><pre class="literallayout">     $ devtool add https://github.com/diversario/node-ssdp
                </pre><p>
                In this example, <code class="filename">devtool</code> fetches the
                specified Git repository, detects the code as Node.js
                code, fetches dependencies using <code class="filename">npm</code>, and
                sets
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                accordingly.
            </p></div></div><div class="section" title="2.6.Â Working With Recipes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-working-with-recipes">2.6.&nbsp;Working With Recipes<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-working-with-recipes">Â¶</a></span></h2></div></div></div><p>
            When building a recipe using the
            <code class="filename">devtool build</code> command, the typical build
            progresses as follows:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    Fetch the source
                    </p></li><li class="listitem"><p>
                    Unpack the source
                    </p></li><li class="listitem"><p>
                    Configure the source
                    </p></li><li class="listitem"><p>
                    Compile the source
                    </p></li><li class="listitem"><p>
                    Install the build output
                    </p></li><li class="listitem"><p>
                    Package the installed output
                    </p></li></ol></div><p>
            For recipes in the workspace, fetching and unpacking is disabled
            as the source tree has already been prepared and is persistent.
            Each of these build steps is defined as a function (task), usually
            with a "do_" prefix (e.g.
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-tasks-fetch" target="_top"><code class="filename">do_fetch</code></a>,
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-tasks-unpack" target="_top"><code class="filename">do_unpack</code></a>,
            and so forth).
            These functions are typically shell scripts but can instead be
            written in Python.
        </p><p>
            If you look at the contents of a recipe, you will see that the
            recipe does not include complete instructions for building the
            software.
            Instead, common functionality is encapsulated in classes inherited
            with the <code class="filename">inherit</code> directive.
            This technique leaves the recipe to describe just the things that
            are specific to the software being built.
            A
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-classes-base" target="_top"><code class="filename">base</code></a>
            class exists that is implicitly inherited by all recipes and
            provides the functionality that most recipes typically need.
        </p><p>
            The remainder of this section presents information useful when
            working with recipes.
        </p><div class="section" title="2.6.1.Â Finding Logs and Work Files"><div class="titlepage"><div><div><h3 class="title" id="sdk-finding-logs-and-work-files">2.6.1.&nbsp;Finding Logs and Work Files<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-finding-logs-and-work-files">Â¶</a></span></h3></div></div></div><p>
                After the first run of the <code class="filename">devtool build</code>
                command, recipes that were previously created using the
                <code class="filename">devtool add</code> command or whose sources were
                modified using the <code class="filename">devtool modify</code>
                command contain symbolic links created within the source tree:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        <code class="filename">oe-logs</code>:
                        This link points to the directory in which log files
                        and run scripts for each build step are created.
                        </p></li><li class="listitem"><p>
                        <code class="filename">oe-workdir</code>:
                        This link points to the temporary work area for the
                        recipe.
                        The following locations under
                        <code class="filename">oe-workdir</code> are particularly
                        useful:
                            </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                    <code class="filename">image/</code>:
                                    Contains all of the files installed during
                                    the
                                    <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-tasks-install" target="_top"><code class="filename">do_install</code></a>
                                    stage.
                                    Within a recipe, this directory is referred
                                    to by the expression
                                    <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-D" target="_top"><code class="filename">D</code></a><code class="filename">}</code>.
                                    </p></li><li class="listitem"><p>
                                    <code class="filename">sysroot-destdir/</code>:
                                    Contains a subset of files installed within
                                    <code class="filename">do_install</code> that have
                                    been put into the shared sysroot.
                                    For more information, see the
                                    "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-sharing-files-between-recipes" title="2.6.3.Â Sharing Files Between Recipes">Sharing Files Between Recipes</a>"
                                    section.
                                    </p></li><li class="listitem"><p>
                                    <code class="filename">packages-split/</code>:
                                    Contains subdirectories for each package
                                    produced by the recipe.
                                    For more information, see the
                                    "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-packaging" title="2.6.4.Â Packaging">Packaging</a>"
                                    section.
                                    </p></li></ul></div><p>
                        </p></li></ul></div><p>
                You can use these links to get more information on what is
                happening at each build step.
            </p></div><div class="section" title="2.6.2.Â Setting Configure Arguments"><div class="titlepage"><div><div><h3 class="title" id="sdk-setting-configure-arguments">2.6.2.&nbsp;Setting Configure Arguments<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-setting-configure-arguments">Â¶</a></span></h3></div></div></div><p>
                If the software your recipe is building uses GNU autoconf,
                then a fixed set of arguments is passed to it to enable
                cross-compilation plus any extras specified by
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-EXTRA_OECONF" target="_top"><code class="filename">EXTRA_OECONF</code></a>
                or
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-PACKAGECONFIG_CONFARGS" target="_top"><code class="filename">PACKAGECONFIG_CONFARGS</code></a>
                set within the recipe.
                If you wish to pass additional options, add them to
                <code class="filename">EXTRA_OECONF</code> or
                <code class="filename">PACKAGECONFIG_CONFARGS</code>.
                Other supported build tools have similar variables
                (e.g.
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-EXTRA_OECMAKE" target="_top"><code class="filename">EXTRA_OECMAKE</code></a>
                for CMake,
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-EXTRA_OESCONS" target="_top"><code class="filename">EXTRA_OESCONS</code></a>
                for Scons, and so forth).
                If you need to pass anything on the <code class="filename">make</code>
                command line, you can use <code class="filename">EXTRA_OEMAKE</code> or the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-PACKAGECONFIG_CONFARGS" target="_top"><code class="filename">PACKAGECONFIG_CONFARGS</code></a>
                variables to do so.
            </p><p>
                You can use the <code class="filename">devtool configure-help</code> command
                to help you set the arguments listed in the previous paragraph.
                The command determines the exact options being passed, and shows
                them to you along with any custom arguments specified through
                <code class="filename">EXTRA_OECONF</code> or
                <code class="filename">PACKAGECONFIG_CONFARGS</code>.
                If applicable, the command also shows you the output of the
                configure script's "ââhelp" option as a reference.
            </p></div><div class="section" title="2.6.3.Â Sharing Files Between Recipes"><div class="titlepage"><div><div><h3 class="title" id="sdk-sharing-files-between-recipes">2.6.3.&nbsp;Sharing Files Between Recipes<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-sharing-files-between-recipes">Â¶</a></span></h3></div></div></div><p>
                Recipes often need to use files provided by other recipes on
                the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#hardware-build-system-term" target="_top">build host</a>.
                For example, an application linking to a common library needs
                access to the library itself and its associated headers.
                The way this access is accomplished within the extensible SDK is
                through the sysroot.
                One sysroot exists per "machine" for which the SDK is being
                built.
                In practical terms, this means a sysroot exists for the target
                machine, and a sysroot exists for the build host.
            </p><p>
                Recipes should never write files directly into the sysroot.
                Instead, files should be installed into standard locations
                during the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-tasks-install" target="_top"><code class="filename">do_install</code></a>
                task within the
                <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-D" target="_top"><code class="filename">D</code></a><code class="filename">}</code>
                directory.
                A subset of these files automatically goes into the sysroot.
                The reason for this limitation is that almost all files that go
                into the sysroot are cataloged in manifests in order to ensure
                they can be removed later when a recipe is modified or removed.
                Thus, the sysroot is able to remain free from stale files.
            </p></div><div class="section" title="2.6.4.Â Packaging"><div class="titlepage"><div><div><h3 class="title" id="sdk-packaging">2.6.4.&nbsp;Packaging<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-packaging">Â¶</a></span></h3></div></div></div><p>
                Packaging is not always particularly relevant within the
                extensible SDK.
                However, if you examine how build output gets into the final image
                on the target device, it is important to understand packaging
                because the contents of the image are expressed in terms of
                packages and not recipes.
            </p><p>
                During the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-tasks-package" target="_top"><code class="filename">do_package</code></a>
                task, files installed during the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-tasks-install" target="_top"><code class="filename">do_install</code></a>
                task are split into one main package, which is almost always
                named the same as the recipe, and into several other packages.
                This separation exists because not all of those installed files
                are useful in every image.
                For example, you probably do not need any of the documentation
                installed in a production image.
                Consequently, for each recipe the documentation files are
                separated into a <code class="filename">-doc</code> package.
                Recipes that package software containing optional modules or
                plugins might undergo additional package splitting as well.
            </p><p>
                After building a recipe, you can see where files have gone by
                looking in the <code class="filename">oe-workdir/packages-split</code>
                directory, which contains a subdirectory for each package.
                Apart from some advanced cases, the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-PACKAGES" target="_top"><code class="filename">PACKAGES</code></a>
                and
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-FILES" target="_top"><code class="filename">FILES</code></a>
                variables controls splitting.
                The <code class="filename">PACKAGES</code> variable lists all of the
                packages to be produced, while the <code class="filename">FILES</code>
                variable specifies which files to include in each package by
                using an override to specify the package.
                For example, <code class="filename">FILES_${PN}</code> specifies the
                files to go into the main package (i.e. the main package has
                the same name as the recipe and
                <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-PN" target="_top"><code class="filename">PN</code></a><code class="filename">}</code>
                evaluates to the recipe name).
                The order of the <code class="filename">PACKAGES</code> value is
                significant.
                For each installed file, the first package whose
                <code class="filename">FILES</code> value matches the file is the
                package into which the file goes.
                Defaults exist for both the <code class="filename">PACKAGES</code> and
                <code class="filename">FILES</code> variables.
                Consequently, you might find you do not even need to set these
                variables in your recipe unless the software the recipe is
                building installs files into non-standard locations.
            </p></div></div><div class="section" title="2.7.Â Restoring the Target Device to its Original State"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-restoring-the-target-device-to-its-original-state">2.7.&nbsp;Restoring the Target Device to its Original State<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-restoring-the-target-device-to-its-original-state">Â¶</a></span></h2></div></div></div><p>
            If you use the <code class="filename">devtool deploy-target</code>
            command to write a recipe's build output to the target, and
            you are working on an existing component of the system, then you
            might find yourself in a situation where you need to restore the
            original files that existed prior to running the
            <code class="filename">devtool deploy-target</code> command.
            Because the <code class="filename">devtool deploy-target</code> command
            backs up any files it overwrites, you can use the
            <code class="filename">devtool undeploy-target</code> command to restore
            those files and remove any other files the recipe deployed.
            Consider the following example:
            </p><pre class="literallayout">     $ devtool undeploy-target lighttpd root@192.168.7.2
            </pre><p>
            If you have deployed multiple applications, you can remove them
            all using the "-a" option thus restoring the target device to its
            original state:
            </p><pre class="literallayout">     $ devtool undeploy-target -a root@192.168.7.2
            </pre><p>
            Information about files deployed to the target as well as any
            backed up files are stored on the target itself.
            This storage, of course, requires some additional space
            on the target machine.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                The <code class="filename">devtool deploy-target</code> and
                <code class="filename">devtool undeploy-target</code> commands do not
                currently interact with any package management system on the
                target device (e.g. RPM or OPKG).
                Consequently, you should not intermingle
                <code class="filename">devtool deploy-target</code> and package
                manager operations on the target device.
                Doing so could result in a conflicting set of files.
            </div><p>
        </p></div><div class="section" title="2.8.Â Installing Additional Items Into the Extensible SDK"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-installing-additional-items-into-the-extensible-sdk">2.8.&nbsp;Installing Additional Items Into the Extensible SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installing-additional-items-into-the-extensible-sdk">Â¶</a></span></h2></div></div></div><p>
            Out of the box the extensible SDK typically only comes with a small
            number of tools and libraries.
            A minimal SDK starts mostly empty and is populated on-demand.
            Sometimes you must explicitly install extra items into the SDK.
            If you need these extra items, you can first search for the items
            using the <code class="filename">devtool search</code> command.
            For example, suppose you need to link to libGL but you are not sure
            which recipe provides libGL.
            You can use the following command to find out:
            </p><pre class="literallayout">     $ devtool search libGL
     mesa                  A free implementation of the OpenGL API
            </pre><p>
            Once you know the recipe (i.e. <code class="filename">mesa</code> in this
            example), you can install it:
            </p><pre class="literallayout">     $ devtool sdk-install mesa
            </pre><p>
            By default, the <code class="filename">devtool sdk-install</code> command
            assumes the item is available in pre-built form from your SDK
            provider.
            If the item is not available and it is acceptable to build the item
            from source, you can add the "-s" option as follows:
            </p><pre class="literallayout">     $ devtool sdk-install -s mesa
            </pre><p>
            It is important to remember that building the item from source
            takes significantly longer than installing the pre-built artifact.
            Also, if no recipe exists for the item you want to add to the SDK,
            you must instead add the item using the
            <code class="filename">devtool add</code> command.
        </p></div><div class="section" title="2.9.Â Applying Updates to an Installed Extensible SDK"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-applying-updates-to-an-installed-extensible-sdk">2.9.&nbsp;Applying Updates to an Installed Extensible SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-applying-updates-to-an-installed-extensible-sdk">Â¶</a></span></h2></div></div></div><p>
            If you are working with an installed extensible SDK that gets
            occasionally updated (e.g. a third-party SDK), then you will need
            to manually "pull down" the updates into the installed SDK.
        </p><p>
            To update your installed SDK, use <code class="filename">devtool</code> as
            follows:
            </p><pre class="literallayout">     $ devtool sdk-update
            </pre><p>
            The previous command assumes your SDK provider has set the default
            update URL for you through the
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_UPDATE_URL" target="_top"><code class="filename">SDK_UPDATE_URL</code></a>
            variable as described in the
            "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-providing-updates-to-the-extensible-sdk-after-installation" title="B.4.Â Providing Updates to the Extensible SDK After Installation">Providing Updates to the Extensible SDK After Installation</a>"
            section.
            If the SDK provider has not set that default URL, you need to
            specify it yourself in the command as follows:
            </p><pre class="literallayout">     $ devtool sdk-update <em class="replaceable"><code>path_to_update_directory</code></em>
            </pre><p>
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                The URL needs to point specifically to a published SDK and
                not to an SDK installer that you would download and install.
            </div><p>
        </p></div><div class="section" title="2.10.Â Creating a Derivative SDK With Additional Components"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-creating-a-derivative-sdk-with-additional-components">2.10.&nbsp;Creating a Derivative SDK With Additional Components<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-creating-a-derivative-sdk-with-additional-components">Â¶</a></span></h2></div></div></div><p>
            You might need to produce an SDK that contains your own custom
            libraries.
            A good example would be if you were a vendor with customers that
            use your SDK to build their own platform-specific software and
            those customers need an SDK that has custom libraries.
            In such a case, you can produce a derivative SDK based on the
            currently installed SDK fairly easily by following these steps:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    If necessary, install an extensible SDK that
                    you want to use as a base for your derivative SDK.
                    </p></li><li class="listitem"><p>
                    Source the environment script for the SDK.
                    </p></li><li class="listitem"><p>
                    Add the extra libraries or other components you want by
                    using the <code class="filename">devtool add</code> command.
                    </p></li><li class="listitem"><p>
                    Run the <code class="filename">devtool build-sdk</code> command.
                    </p></li></ol></div><p>
            The previous steps take the recipes added to the workspace and
            construct a new SDK installer that contains those recipes and the
            resulting binary artifacts.
            The recipes go into their own separate layer in the constructed
            derivative SDK, which leaves the workspace clean and ready for
            users to add their own recipes.
        </p></div></div>

    <div class="chapter" title="ChapterÂ 3.Â Using the Standard SDK" id="sdk-using-the-standard-sdk"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;3.&nbsp;Using the Standard SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-using-the-standard-sdk">Â¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-standard-sdk-intro">3.1. Why use the Standard SDK and What is in It?</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installing-the-sdk">3.2. Installing the SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-running-the-sdk-environment-setup-script">3.3. Running the SDK Environment Setup Script</a></span></dt></dl></div><p>
        This chapter describes the standard SDK and how to install it.
        Information includes unique installation and setup aspects for the
        standard SDK.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            For a side-by-side comparison of main features supported for a
            standard SDK as compared to an extensible SDK, see the
            "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-manual-intro" title="1.1.Â Introduction">Introduction</a>"
            section.
        </div><p>
    </p><p>
        You can use a standard SDK to work on Makefile and Autotools-based
        projects.
        See the
        "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-working-projects" title="ChapterÂ 4.Â Using the SDK Toolchain Directly">Using the SDK Toolchain Directly</a>"
        chapter for more information.
    </p><div class="section" title="3.1.Â Why use the Standard SDK and What is in It?"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-standard-sdk-intro">3.1.&nbsp;Why use the Standard SDK and What is in It?<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-standard-sdk-intro">Â¶</a></span></h2></div></div></div><p>
            The Standard SDK provides a cross-development toolchain and
            libraries tailored to the contents of a specific image.
            You would use the Standard SDK if you want a more traditional
            toolchain experience as compared to the extensible SDK, which
            provides an internal build system and the
            <code class="filename">devtool</code> functionality.
        </p><p>
            The installed Standard SDK consists of several files and
            directories.
            Basically, it contains an SDK environment setup script, some
            configuration files, and host and target root filesystems to
            support usage.
            You can see the directory structure in the
            "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-standard-sdk-directory-structure" title="A.4.Â Installed Standard SDK Directory Structure">Installed Standard SDK Directory Structure</a>"
            section.
        </p></div><div class="section" title="3.2.Â Installing the SDK"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-installing-the-sdk">3.2.&nbsp;Installing the SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installing-the-sdk">Â¶</a></span></h2></div></div></div><p>
            The first thing you need to do is install the SDK on your
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#hardware-build-system-term" target="_top">Build Host</a>
            by running the <code class="filename">*.sh</code> installation script.
        </p><p>
            You can download a tarball installer, which includes the
            pre-built toolchain, the <code class="filename">runqemu</code>
            script, and support files from the appropriate
            <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-3.0.1/toolchain/" target="_top">toolchain</a>
            directory within the Index of Releases.
            Toolchains are available for several 32-bit and 64-bit
            architectures with the <code class="filename">x86_64</code> directories,
            respectively.
            The toolchains the Yocto Project provides are based off the
            <code class="filename">core-image-sato</code> and
            <code class="filename">core-image-minimal</code> images and contain
            libraries appropriate for developing against that image.
        </p><p>
            The names of the tarball installer scripts are such that a
            string representing the host system appears first in the
            filename and then is immediately followed by a string
            representing the target architecture.
            </p><pre class="literallayout">     poky-glibc-<em class="replaceable"><code>host_system</code></em>-<em class="replaceable"><code>image_type</code></em>-<em class="replaceable"><code>arch</code></em>-toolchain-<em class="replaceable"><code>release_version</code></em>.sh

     Where:
         <em class="replaceable"><code>host_system</code></em> is a string representing your development system:

                    i686 or x86_64.

         <em class="replaceable"><code>image_type</code></em> is the image for which the SDK was built:

                    core-image-minimal or core-image-sato.

         <em class="replaceable"><code>arch</code></em> is a string representing the tuned target architecture:

                    aarch64, armv5e, core2-64, i586, mips32r2, mips64, ppc7400, or cortexa8hf-neon.

         <em class="replaceable"><code>release_version</code></em> is a string representing the release number of the Yocto Project:

                    3.0.1, 3.0.1+snapshot
            </pre><p>
            For example, the following SDK installer is for a 64-bit
            development host system and a i586-tuned target architecture
            based off the SDK for <code class="filename">core-image-sato</code> and
            using the current 3.0.1 snapshot:
            </p><pre class="literallayout">     poky-glibc-x86_64-core-image-sato-i586-toolchain-3.0.1.sh
            </pre><p>
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                As an alternative to downloading an SDK, you can build the
                SDK installer.
                For information on building the installer, see the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-building-an-sdk-installer" title="A.2.Â Building an SDK Installer">Building an SDK Installer</a>"
                section.
            </div><p>
        </p><p>
            The SDK and toolchains are self-contained and by default are
            installed into the <code class="filename">poky_sdk</code> folder in your
            home directory.
            You can choose to install the extensible SDK in any location when
            you run the installer.
            However, because files need to be written under that directory
            during the normal course of operation, the location you choose
            for installation must be writable for whichever
            users need to use the SDK.
        </p><p>
            The following command shows how to run the installer given a
            toolchain tarball for a 64-bit x86 development host system and
            a 64-bit x86 target architecture.
            The example assumes the SDK installer is located in
            <code class="filename">~/Downloads/</code> and has execution rights.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                If you do not have write permissions for the directory
                into which you are installing the SDK, the installer
                notifies you and exits.
                For that case, set up the proper permissions in the directory
                and run the installer again.
            </div><p>
            </p><pre class="literallayout">     $ ./Downloads/poky-glibc-x86_64-core-image-sato-i586-toolchain-3.0.1.sh
     Poky (Yocto Project Reference Distro) SDK installer version 3.0.1
     ===============================================================
     Enter target directory for SDK (default: /opt/poky/3.0.1):
     You are about to install the SDK to "/opt/poky/3.0.1". Proceed [Y/n]? Y
     Extracting SDK........................................ ..............................done
     Setting it up...done
     SDK has been successfully set up and is ready to be used.
     Each time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g.
      $ . /opt/poky/3.0.1/environment-setup-i586-poky-linux
            </pre><p>
        </p><p>
            Again, reference the
            "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-standard-sdk-directory-structure" title="A.4.Â Installed Standard SDK Directory Structure">Installed Standard SDK Directory Structure</a>"
            section for more details on the resulting directory structure of
            the installed SDK.
        </p></div><div class="section" title="3.3.Â Running the SDK Environment Setup Script"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-running-the-sdk-environment-setup-script">3.3.&nbsp;Running the SDK Environment Setup Script<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-running-the-sdk-environment-setup-script">Â¶</a></span></h2></div></div></div><p>
            Once you have the SDK installed, you must run the SDK environment
            setup script before you can actually use the SDK.
            This setup script resides in the directory you chose when you
            installed the SDK, which is either the default
            <code class="filename">/opt/poky/3.0.1</code> directory or the directory
            you chose during installation.
        </p><p>
            Before running the script, be sure it is the one that matches the
            architecture for which you are developing.
            Environment setup scripts begin with the string
            "<code class="filename">environment-setup</code>" and include as part of
            their name the tuned target architecture.
            As an example, the following commands set the working directory
            to where the SDK was installed and then source the environment
            setup script.
            In this example, the setup script is for an IA-based
            target machine using i586 tuning:
            </p><pre class="literallayout">     $ source /opt/poky/3.0.1/environment-setup-i586-poky-linux
            </pre><p>
            When you run the setup script, the same environment variables are
            defined as are when you run the setup script for an extensible SDK.
            See the
            "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-running-the-extensible-sdk-environment-setup-script" title="2.3.Â Running the Extensible SDK Environment Setup Script">Running the Extensible SDK Environment Setup Script</a>"
            section for more information.
        </p></div></div>

    <div class="chapter" title="ChapterÂ 4.Â Using the SDK Toolchain Directly" id="sdk-working-projects"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;4.&nbsp;Using the SDK Toolchain Directly<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-working-projects">Â¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#autotools-based-projects">4.1. Autotools-Based Projects</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#makefile-based-projects">4.2. Makefile-Based Projects</a></span></dt></dl></div><p>
        You can use the SDK toolchain directly with Makefile and
        Autotools-based projects.
    </p><div class="section" title="4.1.Â Autotools-Based Projects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="autotools-based-projects">4.1.&nbsp;Autotools-Based Projects<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#autotools-based-projects">Â¶</a></span></h2></div></div></div><p>
            Once you have a suitable
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#cross-development-toolchain" target="_top">cross-development toolchain</a>
            installed, it is very easy to develop a project using the
            <a class="ulink" href="https://en.wikipedia.org/wiki/GNU_Build_System" target="_top">GNU Autotools-based</a>
            workflow, which is outside of the
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#build-system-term" target="_top">OpenEmbedded build system</a>.
        </p><p>
            The following figure presents a simple Autotools workflow.
            </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="630"><tbody><tr><td align="center"><img src="./Yocto Project Application Development and the Extensible Software Development Kit (eSDK)_files/sdk-autotools-flow.png" align="middle" width="630"></td></tr></tbody></table><p>
        </p><p>
            Follow these steps to create a simple Autotools-based
            "Hello World" project:
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                For more information on the GNU Autotools workflow,
                see the same example on the
                <a class="ulink" href="https://developer.gnome.org/anjuta-build-tutorial/stable/create-autotools.html.en" target="_top">GNOME Developer</a>
                site.
            </div><p>
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    <span class="emphasis"><em>Create a Working Directory and Populate It:</em></span>
                    Create a clean directory for your project and then make
                    that directory your working location.
                    </p><pre class="literallayout">     $ mkdir $HOME/helloworld
     $ cd $HOME/helloworld
                    </pre><p>
                    After setting up the directory, populate it with files
                    needed for the flow.
                    You need a project source file, a file to help with
                    configuration, and a file to help create the Makefile,
                    and a README file:
                    <code class="filename">hello.c</code>,
                    <code class="filename">configure.ac</code>,
                    <code class="filename">Makefile.am</code>, and
                    <code class="filename">README</code>, respectively.</p><p> Use the following command to create an empty README
                    file, which is required by GNU Coding Standards:
                    </p><pre class="literallayout">     $ touch README
                    </pre><p>
                    Create the remaining three files as follows:
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            <span class="emphasis"><em><code class="filename">hello.c</code>:</em></span>
                            </p><pre class="literallayout">     #include &lt;stdio.h&gt;

     main()
        {
           printf("Hello World!\n");
        }
                            </pre><p>
                            </p></li><li class="listitem"><p>
                            <span class="emphasis"><em><code class="filename">configure.ac</code>:</em></span>
                            </p><pre class="literallayout">     AC_INIT(hello,0.1)
     AM_INIT_AUTOMAKE([foreign])
     AC_PROG_CC
     AC_CONFIG_FILES(Makefile)
     AC_OUTPUT
                            </pre><p>
                            </p></li><li class="listitem"><p>
                            <span class="emphasis"><em><code class="filename">Makefile.am</code>:</em></span>
                            </p><pre class="literallayout">     bin_PROGRAMS = hello
     hello_SOURCES = hello.c
                            </pre><p>
                            </p></li></ul></div><p>
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Source the Cross-Toolchain
                    Environment Setup File:</em></span>
                    As described earlier in the manual, installing the
                    cross-toolchain creates a cross-toolchain
                    environment setup script in the directory that the SDK
                    was installed.
                    Before you can use the tools to develop your project,
                    you must source this setup script.
                    The script begins with the string "environment-setup"
                    and contains the machine architecture, which is
                    followed by the string "poky-linux".
                    For this example, the command sources a script from the
                    default SDK installation directory that uses the
                    32-bit Intel x86 Architecture and the
                    Zeus Yocto Project release:
                    </p><pre class="literallayout">     $ source /opt/poky/3.0.1/environment-setup-i586-poky-linux
                    </pre><p>
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Create the <code class="filename">configure</code> Script:</em></span>
                    Use the <code class="filename">autoreconf</code> command to
                    generate the <code class="filename">configure</code> script.
                    </p><pre class="literallayout">     $ autoreconf
                    </pre><p>
                    The <code class="filename">autoreconf</code> tool takes care
                    of running the other Autotools such as
                    <code class="filename">aclocal</code>,
                    <code class="filename">autoconf</code>, and
                    <code class="filename">automake</code>.
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                        If you get errors from
                        <code class="filename">configure.ac</code>, which
                        <code class="filename">autoreconf</code> runs, that indicate
                        missing files, you can use the "-i" option, which
                        ensures missing auxiliary files are copied to the build
                        host.
                    </div><p>
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Cross-Compile the Project:</em></span>
                    This command compiles the project using the
                    cross-compiler.
                    The
                    <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-CONFIGURE_FLAGS" target="_top"><code class="filename">CONFIGURE_FLAGS</code></a>
                    environment variable provides the minimal arguments for
                    GNU configure:
                    </p><pre class="literallayout">     $ ./configure ${CONFIGURE_FLAGS}
                    </pre><p>
                    For an Autotools-based project, you can use the
                    cross-toolchain by just passing the appropriate host
                    option to <code class="filename">configure.sh</code>.
                    The host option you use is derived from the name of the
                    environment setup script found in the directory in which
                    you installed the cross-toolchain.
                    For example, the host option for an ARM-based target that
                    uses the GNU EABI is
                    <code class="filename">armv5te-poky-linux-gnueabi</code>.
                    You will notice that the name of the script is
                    <code class="filename">environment-setup-armv5te-poky-linux-gnueabi</code>.
                    Thus, the following command works to update your project
                    and rebuild it using the appropriate cross-toolchain tools:
                    </p><pre class="literallayout">     $ ./configure --host=armv5te-poky-linux-gnueabi --with-libtool-sysroot=<em class="replaceable"><code>sysroot_dir</code></em>
                    </pre><p>
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Make and Install the Project:</em></span>
                    These two commands generate and install the project
                    into the destination directory:
                    </p><pre class="literallayout">     $ make
     $ make install DESTDIR=./tmp
                    </pre><p>
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                        To learn about environment variables established
                        when you run the cross-toolchain environment setup
                        script and how they are used or overridden when
                        the Makefile, see the
                        "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#makefile-based-projects" title="4.2.Â Makefile-Based Projects">Makefile-Based Projects</a>"
                        section.
                    </div><p>
                    This next command is a simple way to verify the
                    installation of your project.
                    Running the command prints the architecture on which
                    the binary file can run.
                    This architecture should be the same architecture that
                    the installed cross-toolchain supports.
                    </p><pre class="literallayout">     $ file ./tmp/usr/local/bin/hello
                    </pre><p>
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Execute Your Project:</em></span>
                    To execute the project, you would need to run it on your
                    target hardware.
                    If your target hardware happens to be your build host,
                    you could run the project as follows:
                    </p><pre class="literallayout">     $ ./tmp/usr/local/bin/hello
                    </pre><p>
                    As expected, the project displays the "Hello World!"
                    message.
                    </p></li></ol></div><p>
        </p></div><div class="section" title="4.2.Â Makefile-Based Projects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="makefile-based-projects">4.2.&nbsp;Makefile-Based Projects<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#makefile-based-projects">Â¶</a></span></h2></div></div></div><p>
            Simple Makefile-based projects use and interact with the
            cross-toolchain environment variables established when you run
            the cross-toolchain environment setup script.
            The environment variables are subject to general
            <code class="filename">make</code> rules.
        </p><p>
            This section presents a simple Makefile development flow and
            provides an example that lets you see how you can use
            cross-toolchain environment variables and Makefile variables
            during development.
            </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tbody><tr><td align="center"><img src="./Yocto Project Application Development and the Extensible Software Development Kit (eSDK)_files/sdk-makefile-flow.png" align="middle" width="540"></td></tr></tbody></table><p>
        </p><p>
            The main point of this section is to explain the following three
            cases regarding variable behavior:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="emphasis"><em>Case 1 - No Variables Set in the
                    <code class="filename">Makefile</code> Map to Equivalent
                    Environment Variables Set in the SDK Setup Script:</em></span>
                    Because matching variables are not specifically set in the
                    <code class="filename">Makefile</code>, the variables retain their
                    values based on the environment setup script.
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Case 2 - Variables Are Set in the Makefile that
                    Map to Equivalent Environment Variables from the SDK
                    Setup Script:</em></span>
                    Specifically setting matching variables in the
                    <code class="filename">Makefile</code> during the build results in
                    the environment settings of the variables being
                    overwritten.
                    In this case, the variables you set in the
                    <code class="filename">Makefile</code> are used.
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Case 3 - Variables Are Set Using the Command Line
                    that Map to Equivalent Environment Variables from the
                    SDK Setup Script:</em></span>
                    Executing the <code class="filename">Makefile</code> from the
                    command line results in the environment variables being
                    overwritten.
                    In this case, the command-line content is used.
                    </p></li></ul></div><p>
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                Regardless of how you set your variables, if you use
                the "-e" option with <code class="filename">make</code>, the
                variables from the SDK setup script take precedence:
                <pre class="literallayout">     $ make -e <em class="replaceable"><code>target</code></em>
                </pre></div><p>
        </p><p>
            The remainder of this section presents a simple Makefile example
            that demonstrates these variable behaviors.
        </p><p>
            In a new shell environment variables are not established for the
            SDK until you run the setup script.
            For example, the following commands show a null value for the
            compiler variable (i.e.
            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-CC" target="_top"><code class="filename">CC</code></a>).
            </p><pre class="literallayout">     $ echo ${CC}

     $
            </pre><p>
            Running the SDK setup script for a 64-bit build host and an
            i586-tuned target architecture for a
            <code class="filename">core-image-sato</code> image using the current
            3.0.1 Yocto Project release and then echoing that variable
            shows the value established through the script:
            </p><pre class="literallayout">     $ source /opt/poky/3.0.1/environment-setup-i586-poky-linux
     $ echo ${CC}
     i586-poky-linux-gcc -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux
            </pre><p>
        </p><p>
            To illustrate variable use, work through this simple "Hello World!"
            example:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    <span class="emphasis"><em>Create a Working Directory and Populate It:</em></span>
                    Create a clean directory for your project and then make
                    that directory your working location.
                    </p><pre class="literallayout">     $ mkdir $HOME/helloworld
     $ cd $HOME/helloworld
                    </pre><p>
                    After setting up the directory, populate it with files
                    needed for the flow.
                    You need a <code class="filename">main.c</code> file from which you
                    call your function, a <code class="filename">module.h</code> file
                    to contain headers, and a <code class="filename">module.c</code>
                    that defines your function.
                    </p><p>Create the three files as follows:
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                                <span class="emphasis"><em><code class="filename">main.c</code>:</em></span>
                                </p><pre class="literallayout">     #include "module.h"
     void sample_func();
     int main()
     {
     	sample_func();
     	return 0;
     }
                                </pre><p>
                                </p></li><li class="listitem"><p>
                                <span class="emphasis"><em><code class="filename">module.h</code>:</em></span>
                                </p><pre class="literallayout">     #include &lt;stdio.h&gt;
     void sample_func();
                                </pre><p>
                                </p></li><li class="listitem"><p>
                                <span class="emphasis"><em><code class="filename">module.c</code>:</em></span>
                                </p><pre class="literallayout">     #include "module.h"
     void sample_func()
     {
	     printf("Hello World!");
	     printf("\n");
     }
                                </pre><p>
                                </p></li></ul></div><p>
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Source the Cross-Toolchain Environment Setup File:</em></span>
                    As described earlier in the manual, installing the
                    cross-toolchain creates a cross-toolchain environment setup
                    script in the directory that the SDK was installed.
                    Before you can use the tools to develop your project,
                    you must source this setup script.
                    The script begins with the string "environment-setup"
                    and contains the machine architecture, which is
                    followed by the string "poky-linux".
                    For this example, the command sources a script from the
                    default SDK installation directory that uses the
                    32-bit Intel x86 Architecture and the
                    Zeus Yocto Project release:
                    </p><pre class="literallayout">     $ source /opt/poky/3.0.1/environment-setup-i586-poky-linux
                    </pre><p>
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Create the <code class="filename">Makefile</code>:</em></span>
                    For this example, the Makefile contains two lines that
                    can be used to set the <code class="filename">CC</code> variable.
                    One line is identical to the value that is set when you
                    run the SDK environment setup script, and the other line
                    sets <code class="filename">CC</code> to "gcc", the default GNU
                    compiler on the build host:
                    </p><pre class="literallayout">     # CC=i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux
     # CC="gcc"
     all: main.o module.o
     	 ${CC} main.o module.o -o target_bin
     main.o: main.c module.h
	     ${CC} -I . -c main.c
     module.o: module.c module.h
	     ${CC} -I . -c module.c
     clean:
	     rm -rf *.o
	     rm target_bin
                    </pre><p>
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Make the Project:</em></span>
                    Use the <code class="filename">make</code> command to create the
                    binary output file.
                    Because variables are commented out in the Makefile,
                    the value used for <code class="filename">CC</code> is the value
                    set when the SDK environment setup file was run:
                    </p><pre class="literallayout">     $ make
     i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c main.c
     i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c module.c
     i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux main.o module.o -o target_bin
                    </pre><p>
                    From the results of the previous command, you can see that
                    the compiler used was the compiler established through
                    the <code class="filename">CC</code> variable defined in the
                    setup script.</p><p>You can override the <code class="filename">CC</code>
                    environment variable with the same variable as set from
                    the Makefile by uncommenting the line in the Makefile
                    and running <code class="filename">make</code> again.
                    </p><pre class="literallayout">     $ make clean
     rm -rf *.o
     rm target_bin
     #
     # Edit the Makefile by uncommenting the line that sets CC to "gcc"
     #
     $ make
     gcc -I . -c main.c
     gcc -I . -c module.c
     gcc main.o module.o -o target_bin
                    </pre><p>
                    As shown in the previous example, the cross-toolchain
                    compiler is not used.
                    Rather, the default compiler is used.</p><p>This next case shows how to override a variable
                    by providing the variable as part of the command line.
                    Go into the Makefile and re-insert the comment character
                    so that running <code class="filename">make</code> uses
                    the established SDK compiler.
                    However, when you run <code class="filename">make</code>, use a
                    command-line argument to set <code class="filename">CC</code>
                    to "gcc":
                    </p><pre class="literallayout">     $ make clean
     rm -rf *.o
     rm target_bin
     #
     # Edit the Makefile to comment out the line setting CC to "gcc"
     #
     $ make
     i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c main.c
     i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c module.c
     i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux main.o module.o -o target_bin
     $ make clean
     rm -rf *.o
     rm target_bin
     $ make CC="gcc"
     gcc -I . -c main.c
     gcc -I . -c module.c
     gcc main.o module.o -o target_bin
                    </pre><p>
                    In the previous case, the command-line argument overrides
                    the SDK environment variable.</p><p>In this last case, edit Makefile again to use the
                    "gcc" compiler but then use the "-e" option on the
                    <code class="filename">make</code> command line:
                    </p><pre class="literallayout">     $ make clean
     rm -rf *.o
     rm target_bin
     #
     # Edit the Makefile to use "gcc"
     #
     $ make
     gcc -I . -c main.c
     gcc -I . -c module.c
     gcc main.o module.o -o target_bin
     $ make clean
     rm -rf *.o
     rm target_bin
     $ make -e
     i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c main.c
     i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux -I . -c module.c
     i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux main.o module.o -o target_bin
                    </pre><p>
                    In the previous case, the "-e" option forces
                    <code class="filename">make</code> to use the SDK environment
                    variables regardless of the values in the Makefile.
                    </p></li><li class="listitem"><p>
                    <span class="emphasis"><em>Execute Your Project:</em></span>
                    To execute the project (i.e.
                    <code class="filename">target_bin</code>), use the following
                    command:
                    </p><pre class="literallayout">     $ ./target_bin
     Hello World!
                    </pre><p>
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                        If you used the cross-toolchain compiler to build
                        <code class="filename">target_bin</code> and your build host
                        differs in architecture from that of the target
                        machine, you need to run your project on the target
                        device.
                    </div><p>
                    As expected, the project displays the "Hello World!"
                    message.
                    </p></li></ol></div><p>
        </p></div></div>

    <div class="appendix" title="AppendixÂ A.Â Obtaining the SDK" id="sdk-appendix-obtain"><div class="titlepage"><div><div><h2 class="title">Appendix&nbsp;A.&nbsp;Obtaining the SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-appendix-obtain">Â¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-locating-pre-built-sdk-installers">A.1. Locating Pre-Built SDK Installers</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-building-an-sdk-installer">A.2. Building an SDK Installer</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-extracting-the-root-filesystem">A.3. Extracting the Root Filesystem</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-standard-sdk-directory-structure">A.4. Installed Standard SDK Directory Structure</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-extensible-sdk-directory-structure">A.5. Installed Extensible SDK Directory Structure</a></span></dt></dl></div><div class="section" title="A.1.Â Locating Pre-Built SDK Installers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-locating-pre-built-sdk-installers">A.1.&nbsp;Locating Pre-Built SDK Installers<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-locating-pre-built-sdk-installers">Â¶</a></span></h2></div></div></div><p>
        You can use existing, pre-built toolchains by locating and running
        an SDK installer script that ships with the Yocto Project.
        Using this method, you select and download an architecture-specific
        SDK installer and then run the script to hand-install the
        toolchain.
    </p><p>
        Follow these steps to locate and hand-install the toolchain:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <span class="emphasis"><em>Go to the Installers Directory:</em></span>
                Go to <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-3.0.1/toolchain/" target="_top">http://downloads.yoctoproject.org/releases/yocto/yocto-3.0.1/toolchain/</a>
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Open the Folder for Your Build Host:</em></span>
                Open the folder that matches your
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#build-system-term" target="_top">build host</a>
                (i.e. <code class="filename">i686</code> for 32-bit machines or
                <code class="filename">x86_64</code> for 64-bit machines).
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Locate and Download the SDK Installer:</em></span>
                You need to find and download the installer appropriate for
                your build host, target hardware, and image type.
                </p><p>The installer files (<code class="filename">*.sh</code>) follow
                this naming convention:
                </p><pre class="literallayout">     poky-glibc-<em class="replaceable"><code>host_system</code></em>-core-image-<em class="replaceable"><code>type</code></em>-<em class="replaceable"><code>arch</code></em>-toolchain[-ext]-<em class="replaceable"><code>release</code></em>.sh

     Where:
         <em class="replaceable"><code>host_system</code></em> is a string representing your development system:
                "i686" or "x86_64"

         <em class="replaceable"><code>type</code></em> is a string representing the image:
                "sato" or "minimal"

         <em class="replaceable"><code>arch</code></em> is a string representing the target architecture:
                "aarch64", "armv5e", "core2-64", "coretexa8hf-neon", "i586", "mips32r2",
                "mips64", or "ppc7400"

         <em class="replaceable"><code>release</code></em> is the version of Yocto Project.

         NOTE:
            The standard SDK installer does not have the "-ext" string as
            part of the filename.

                </pre><p>
                The toolchains provided by the Yocto Project are based off of
                the <code class="filename">core-image-sato</code> and
                <code class="filename">core-image-minimal</code> images and contain
                libraries appropriate for developing against those images.
                </p><p>For example, if your build host is a 64-bit x86 system
                and you need an extended SDK for a 64-bit core2 target, go
                into the <code class="filename">x86_64</code> folder and download the
                following installer:
                </p><pre class="literallayout">     poky-glibc-x86_64-core-image-sato-core2-64-toolchain-ext-3.0.1.sh
                </pre><p>
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Run the Installer:</em></span>
                Be sure you have execution privileges and run the installer.
                Following is an example from the <code class="filename">Downloads</code>
                directory:
                </p><pre class="literallayout">     $ ~/Downloads/poky-glibc-x86_64-core-image-sato-core2-64-toolchain-ext-3.0.1.sh
                </pre><p>
                During execution of the script, you choose the root location
                for the toolchain.
                See the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-standard-sdk-directory-structure" title="A.4.Â Installed Standard SDK Directory Structure">Installed Standard SDK Directory Structure</a>"
                section and the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-extensible-sdk-directory-structure" title="A.5.Â Installed Extensible SDK Directory Structure">Installed Extensible SDK Directory Structure</a>"
                section for more information.
                </p></li></ol></div><p>
    </p></div><div class="section" title="A.2.Â Building an SDK Installer"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-building-an-sdk-installer">A.2.&nbsp;Building an SDK Installer<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-building-an-sdk-installer">Â¶</a></span></h2></div></div></div><p>
        As an alternative to locating and downloading an SDK installer,
        you can build the SDK installer.
        Follow these steps:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <span class="emphasis"><em>Set Up the Build Environment:</em></span>
                Be sure you are set up to use BitBake in a shell.
                See the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/dev-manual/dev-manual.html#dev-preparing-the-build-host" target="_top">Preparing the Build Host</a>"
                section in the Yocto Project Development Tasks Manual for
                information on how to get a build host ready that is either a
                native Linux machine or a machine that uses CROPS.
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Clone the <code class="filename">poky</code> Repository:</em></span>
                You need to have a local copy of the Yocto Project
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#source-directory" target="_top">Source Directory</a>
                (i.e. a local <code class="filename">poky</code> repository).
                See the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/dev-manual/dev-manual.html#cloning-the-poky-repository" target="_top">Cloning the <code class="filename">poky</code> Repository</a>"
                and possibly the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/dev-manual/dev-manual.html#checking-out-by-branch-in-poky" target="_top">Checking Out by Branch in Poky</a>"
                and
                "<a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/dev-manual/dev-manual.html#checkout-out-by-tag-in-poky" target="_top">Checking Out by Tag in Poky</a>"
                sections all in the Yocto Project Development Tasks Manual for
                information on how to clone the <code class="filename">poky</code>
                repository and check out the appropriate branch for your work.
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Initialize the Build Environment:</em></span>
                While in the root directory of the Source Directory (i.e.
                <code class="filename">poky</code>), run the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#structure-core-script" target="_top"><code class="filename">oe-init-build-env</code></a>
                environment setup script to define the OpenEmbedded
                build environment on your build host.
                </p><pre class="literallayout">     $ source oe-init-build-env
                </pre><p>
                Among other things, the script creates the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#build-directory" target="_top">Build Directory</a>,
                which is <code class="filename">build</code> in this case
                and is located in the Source Directory.
                After the script runs, your current working directory
                is set to the <code class="filename">build</code> directory.
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Make Sure You Are Building an Installer for the Correct Machine:</em></span>
                Check to be sure that your
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-MACHINE" target="_top"><code class="filename">MACHINE</code></a>
                variable in the <code class="filename">local.conf</code> file in your
                Build Directory matches the architecture for which you are
                building.
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Make Sure Your SDK Machine is Correctly Set:</em></span>
                If you are building a toolchain designed to run on an
                architecture that differs from your current development host
                machine (i.e. the build host), be sure that the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDKMACHINE" target="_top"><code class="filename">SDKMACHINE</code></a>
                variable in the <code class="filename">local.conf</code> file in your
                Build Directory is correctly set.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    If you are building an SDK installer for the Extensible
                    SDK, the <code class="filename">SDKMACHINE</code> value must be
                    set for the architecture of the machine you are using to
                    build the installer.
                    If <code class="filename">SDKMACHINE</code> is not set appropriately,
                    the build fails and provides an error message similar to
                    the following:
                    <pre class="literallayout">     The extensible SDK can currently only be built for the same architecture as the machine being built on - SDK_ARCH is
     set to i686 (likely via setting SDKMACHINE) which is different from the architecture of the build machine (x86_64).
     Unable to continue.
                    </pre></div><p>
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Build the SDK Installer:</em></span>
                To build the SDK installer for a standard SDK and populate
                the SDK image, use the following command form.
                Be sure to replace <em class="replaceable"><code>image</code></em> with
                an image (e.g. "core-image-sato"):
                </p><pre class="literallayout">     $ bitbake <em class="replaceable"><code>image</code></em> -c populate_sdk
                </pre><p>
                You can do the same for the extensible SDK using this command
                form:
                </p><pre class="literallayout">     $ bitbake <em class="replaceable"><code>image</code></em> -c populate_sdk_ext
                </pre><p>
                These commands produce an SDK installer that contains the
                sysroot that matches your target root filesystem.</p><p>When the <code class="filename">bitbake</code> command completes,
                the SDK installer will be in
                <code class="filename">tmp/deploy/sdk</code> in the Build Directory.
                </p><div class="note" title="Notes" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Notes</h3><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            By default, the previous BitBake command does not
                            build static binaries.
                            If you want to use the toolchain to build these
                            types of libraries, you need to be sure your SDK
                            has the appropriate static development libraries.
                            Use the
                            <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-TOOLCHAIN_TARGET_TASK" target="_top"><code class="filename">TOOLCHAIN_TARGET_TASK</code></a>
                            variable inside your <code class="filename">local.conf</code>
                            file before building the SDK installer.
                            Doing so ensures that the eventual SDK installation
                            process installs the appropriate library packages
                            as part of the SDK.
                            Following is an example using
                            <code class="filename">libc</code> static development
                            libraries:
                            </p><pre class="literallayout">     TOOLCHAIN_TARGET_TASK_append = " libc-staticdev"
                            </pre><p>
                            </p></li></ul></div></div><p>
            </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Run the Installer:</em></span>
                You can now run the SDK installer from
                <code class="filename">tmp/deploy/sdk</code> in the Build Directory.
                Following is an example:
                </p><pre class="literallayout">     $ cd ~/poky/build/tmp/deploy/sdk
     $ ./poky-glibc-x86_64-core-image-sato-core2-64-toolchain-ext-3.0.1.sh
                </pre><p>
                During execution of the script, you choose the root location
                for the toolchain.
                See the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-standard-sdk-directory-structure" title="A.4.Â Installed Standard SDK Directory Structure">Installed Standard SDK Directory Structure</a>"
                section and the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-extensible-sdk-directory-structure" title="A.5.Â Installed Extensible SDK Directory Structure">Installed Extensible SDK Directory Structure</a>"
                section for more information.
                </p></li></ol></div><p>
    </p></div><div class="section" title="A.3.Â Extracting the Root Filesystem"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-extracting-the-root-filesystem">A.3.&nbsp;Extracting the Root Filesystem<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-extracting-the-root-filesystem">Â¶</a></span></h2></div></div></div><p>
        After installing the toolchain, for some use cases you
        might need to separately extract a root filesystem:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                You want to boot the image using NFS.
                </p></li><li class="listitem"><p>
                You want to use the root filesystem as the
                target sysroot.
                </p></li><li class="listitem"><p>
                You want to develop your target application
                using the root filesystem as the target sysroot.
                </p></li></ul></div><p>
    </p><p>
        Follow these steps to extract the root filesystem:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <span class="emphasis"><em>Locate and Download the Tarball for the Pre-Built
                Root Filesystem Image File:</em></span>
                You need to find and download the root filesystem image
                file that is appropriate for your target system.
                These files are kept in machine-specific folders in the
                <a class="ulink" href="http://downloads.yoctoproject.org/releases/yocto/yocto-3.0.1/machines/" target="_top">Index of Releases</a>
                in the "machines" directory.</p><p>The machine-specific folders of the "machines" directory
                contain tarballs (<code class="filename">*.tar.bz2</code>) for supported
                machines.
                These directories also contain flattened root filesystem
                image files (<code class="filename">*.ext4</code>), which you can use
                with QEMU directly.</p><p>The pre-built root filesystem image files
                follow these naming conventions:
                </p><pre class="literallayout">
     core-image-<em class="replaceable"><code>profile</code></em>-<em class="replaceable"><code>arch</code></em>.tar.bz2

     Where:
         <em class="replaceable"><code>profile</code></em> is the filesystem image's profile:
                   lsb, lsb-dev, lsb-sdk, minimal, minimal-dev, minimal-initramfs,
                   sato, sato-dev, sato-sdk, sato-sdk-ptest. For information on
                   these types of image profiles, see the "<a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-images" target="_top">Images</a>" chapter in
                   the Yocto Project Reference Manual.

         <em class="replaceable"><code>arch</code></em> is a string representing the target architecture:
                   beaglebone-yocto, beaglebone-yocto-lsb, edgerouter, edgerouter-lsb,
                   genericx86, genericx86-64, genericx86-64-lsb, genericx86-lsb,
                   mpc8315e-rdb, mpc8315e-rdb-lsb, and qemu*.



                </pre><p>
                The root filesystems provided by the Yocto Project are based
                off of the <code class="filename">core-image-sato</code> and
                <code class="filename">core-image-minimal</code> images.
                </p><p>For example, if you plan on using a BeagleBone device
                as your target hardware and your image is a
                <code class="filename">core-image-sato-sdk</code>
                image, you can download the following file:
                </p><pre class="literallayout">     core-image-sato-sdk-beaglebone-yocto.tar.bz2
                </pre><p>
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Initialize the Cross-Development Environment:</em></span>
                You must <code class="filename">source</code> the cross-development
                environment setup script to establish necessary environment
                variables.</p><p>This script is located in the top-level directory in
                which you installed the toolchain (e.g.
                <code class="filename">poky_sdk</code>).</p><p>Following is an example based on the toolchain installed
                in the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-locating-pre-built-sdk-installers" title="A.1.Â Locating Pre-Built SDK Installers">Locating Pre-Built SDK Installers</a>"
                section:
                </p><pre class="literallayout">     $ source ~/poky_sdk/environment-setup-core2-64-poky-linux
                </pre><p>
                </p></li><li class="listitem"><p>
                <span class="emphasis"><em>Extract the Root Filesystem:</em></span>
                Use the <code class="filename">runqemu-extract-sdk</code> command
                and provide the root filesystem image.</p><p>Following is an example command that extracts the root
                filesystem from a previously built root filesystem image that
                was downloaded from the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/overview-manual/overview-manual.html#index-downloads" target="_top">Index of Releases</a>.
                This command extracts the root filesystem into the
                <code class="filename">core2-64-sato</code> directory:
                </p><pre class="literallayout">     $ runqemu-extract-sdk ~/Downloads/core-image-sato-sdk-beaglebone-yocto.tar.bz2 ~/beaglebone-sato
                </pre><p>
                You could now point to the target sysroot at
                <code class="filename">beablebone-sato</code>.
                </p></li></ol></div><p>
    </p></div><div class="section" title="A.4.Â Installed Standard SDK Directory Structure"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-installed-standard-sdk-directory-structure">A.4.&nbsp;Installed Standard SDK Directory Structure<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-standard-sdk-directory-structure">Â¶</a></span></h2></div></div></div><p>
        The following figure shows the resulting directory structure after
        you install the Standard SDK by running the <code class="filename">*.sh</code>
        SDK installation script:
    </p><p>
        <img src="./Yocto Project Application Development and the Extensible Software Development Kit (eSDK)_files/sdk-installed-standard-sdk-directory.png" align="middle" width="432">
    </p><p>
        The installed SDK consists of an environment setup script for the SDK,
        a configuration file for the target, a version file for the target,
        and the root filesystem (<code class="filename">sysroots</code>) needed to
        develop objects for the target system.
    </p><p>
        Within the figure, italicized text is used to indicate replaceable
        portions of the file or directory name.
        For example,
        <em class="replaceable"><code>install_dir</code></em>/<em class="replaceable"><code>version</code></em>
        is the directory where the SDK is installed.
        By default, this directory is <code class="filename">/opt/poky/</code>.
        And, <em class="replaceable"><code>version</code></em> represents the specific
        snapshot of the SDK (e.g. <code class="filename">3.0.1</code>).
        Furthermore, <em class="replaceable"><code>target</code></em> represents the target
        architecture (e.g. <code class="filename">i586</code>) and
        <em class="replaceable"><code>host</code></em> represents the development system's
        architecture (e.g. <code class="filename">x86_64</code>).
        Thus, the complete names of the two directories within the
        <code class="filename">sysroots</code> could be
        <code class="filename">i586-poky-linux</code> and
        <code class="filename">x86_64-pokysdk-linux</code> for the target and host,
        respectively.
    </p></div><div class="section" title="A.5.Â Installed Extensible SDK Directory Structure"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-installed-extensible-sdk-directory-structure">A.5.&nbsp;Installed Extensible SDK Directory Structure<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-installed-extensible-sdk-directory-structure">Â¶</a></span></h2></div></div></div><p>
        The following figure shows the resulting directory structure after
        you install the Extensible SDK by running the <code class="filename">*.sh</code>
        SDK installation script:
    </p><p>
        <img src="./Yocto Project Application Development and the Extensible Software Development Kit (eSDK)_files/sdk-installed-extensible-sdk-directory.png" align="middle" width="432">
    </p><p>
        The installed directory structure for the extensible SDK is quite
        different than the installed structure for the standard SDK.
        The extensible SDK does not separate host and target parts in the
        same manner as does the standard SDK.
        The extensible SDK uses an embedded copy of the OpenEmbedded
        build system, which has its own sysroots.
    </p><p>
        Of note in the directory structure are an environment setup script
        for the SDK, a configuration file for the target, a version file for
        the target, and log files for the OpenEmbedded build system
        preparation script run by the installer and BitBake.
    </p><p>
        Within the figure, italicized text is used to indicate replaceable
        portions of the file or directory name.
        For example,
        <em class="replaceable"><code>install_dir</code></em> is the directory where the SDK
        is installed, which is <code class="filename">poky_sdk</code> by default, and
        <em class="replaceable"><code>target</code></em> represents the target
        architecture (e.g. <code class="filename">i586</code>).
    </p></div></div>

    <div class="appendix" title="AppendixÂ B.Â Customizing the Extensible SDK" id="sdk-appendix-customizing"><div class="titlepage"><div><div><h2 class="title">Appendix&nbsp;B.&nbsp;Customizing the Extensible SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-appendix-customizing">Â¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-configuring-the-extensible-sdk">B.1. Configuring the Extensible SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#adjusting-the-extensible-sdk-to-suit-your-build-hosts-setup">B.2. Adjusting the Extensible SDK to Suit Your Build Host's Setup</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-changing-the-sdk-installer-title">B.3. Changing the Extensible SDK Installer Title</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-providing-updates-to-the-extensible-sdk-after-installation">B.4. Providing Updates to the Extensible SDK After Installation</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-changing-the-default-sdk-installation-directory">B.5. Changing the Default SDK Installation Directory</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-providing-additional-installable-extensible-sdk-content">B.6. Providing Additional Installable Extensible SDK Content</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-minimizing-the-size-of-the-extensible-sdk-installer-download">B.7. Minimizing the Size of the Extensible SDK Installer Download</a></span></dt></dl></div><p>
    This appendix describes customizations you can apply to the extensible SDK.
</p><div class="section" title="B.1.Â Configuring the Extensible SDK"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-configuring-the-extensible-sdk">B.1.&nbsp;Configuring the Extensible SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-configuring-the-extensible-sdk">Â¶</a></span></h2></div></div></div><p>
        The extensible SDK primarily consists of a pre-configured copy of
        the OpenEmbedded build system from which it was produced.
        Thus, the SDK's configuration is derived using that build system and
        the filters shown in the following list.
        When these filters are present, the OpenEmbedded build system applies
        them against <code class="filename">local.conf</code> and
        <code class="filename">auto.conf</code>:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                Variables whose values start with "/" are excluded since the
                assumption is that those values are paths that are likely to
                be specific to the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#hardware-build-system-term" target="_top">build host</a>.
                </p></li><li class="listitem"><p>
                Variables listed in
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_LOCAL_CONF_BLACKLIST" target="_top"><code class="filename">SDK_LOCAL_CONF_BLACKLIST</code></a>
                are excluded.
                These variables are not allowed through from the OpenEmbedded
                build system configuration into the extensible SDK
                configuration.
                Typically, these variables are specific to the machine on
                which the build system is running and could be problematic
                as part of the extensible SDK configuration.</p><p>For a list of the variables excluded by default, see the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_LOCAL_CONF_BLACKLIST" target="_top"><code class="filename">SDK_LOCAL_CONF_BLACKLIST</code></a>
                in the glossary of the Yocto Project Reference Manual.
                </p></li><li class="listitem"><p>
                Variables listed in
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_LOCAL_CONF_WHITELIST" target="_top"><code class="filename">SDK_LOCAL_CONF_WHITELIST</code></a>
                are included.
                Including a variable in the value of
                <code class="filename">SDK_LOCAL_CONF_WHITELIST</code> overrides either
                of the previous two filters.
                The default value is blank.
                </p></li><li class="listitem"><p>
                Classes inherited globally with
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-INHERIT" target="_top"><code class="filename">INHERIT</code></a>
                that are listed in
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_INHERIT_BLACKLIST" target="_top"><code class="filename">SDK_INHERIT_BLACKLIST</code></a>
                are disabled.
                Using <code class="filename">SDK_INHERIT_BLACKLIST</code> to disable
                these classes is the typical method to disable classes that
                are problematic or unnecessary in the SDK context.
                The default value blacklists the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-classes-buildhistory" target="_top"><code class="filename">buildhistory</code></a>
                and
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-classes-icecc" target="_top"><code class="filename">icecc</code></a>
                classes.
                </p></li></ul></div><p>
        Additionally, the contents of <code class="filename">conf/sdk-extra.conf</code>,
        when present, are appended to the end of
        <code class="filename">conf/local.conf</code> within the produced SDK, without
        any filtering.
        The <code class="filename">sdk-extra.conf</code> file is particularly useful
        if you want to set a variable value just for the SDK and not the
        OpenEmbedded build system used to create the SDK.
    </p></div><div class="section" title="B.2.Â Adjusting the Extensible SDK to Suit Your Build Host&#39;s Setup"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="adjusting-the-extensible-sdk-to-suit-your-build-hosts-setup">B.2.&nbsp;Adjusting the Extensible SDK to Suit Your Build Host's Setup<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#adjusting-the-extensible-sdk-to-suit-your-build-hosts-setup">Â¶</a></span></h2></div></div></div><p>
        In most cases, the extensible SDK defaults should work with your
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#hardware-build-system-term" target="_top">build host's</a>
        setup.
        However, some cases exist for which you might consider making
        adjustments:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                If your SDK configuration inherits additional classes
                using the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-INHERIT" target="_top"><code class="filename">INHERIT</code></a>
                variable and you do not need or want those classes enabled in
                the SDK, you can blacklist them by adding them to the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_INHERIT_BLACKLIST" target="_top"><code class="filename">SDK_INHERIT_BLACKLIST</code></a>
                variable as described in the fourth bullet of the previous
                section.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    The default value of
                    <code class="filename">SDK_INHERIT_BLACKLIST</code> is set using
                    the "?=" operator.
                    Consequently, you will need to either define the entire
                    list by using the "=" operator, or you will need to append
                    a value using either "_append" or the "+=" operator.
                    You can learn more about these operators in the
                    "<a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/bitbake-user-manual/bitbake-user-manual.html#basic-syntax" target="_top">Basic Syntax</a>"
                    section of the BitBake User Manual.
                </div><p>.
                </p></li><li class="listitem"><p>
                If you have classes or recipes that add additional tasks to
                the standard build flow (i.e. the tasks execute as the recipe
                builds as opposed to being called explicitly), then you need
                to do one of the following:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                        After ensuring the tasks are
                        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/overview-manual/overview-manual.html#shared-state-cache" target="_top">shared state</a>
                        tasks (i.e. the output of the task is saved to and
                        can be restored from the shared state cache) or
                        ensuring the tasks are able to be produced quickly from
                        a task that is a shared state task, add the task name
                        to the value of
                        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_RECRDEP_TASKS" target="_top"><code class="filename">SDK_RECRDEP_TASKS</code></a>.
                        </p></li><li class="listitem"><p>
                        Disable the tasks if they are added by a class and
                        you do not need the functionality the class provides
                        in the extensible SDK.
                        To disable the tasks, add the class to the
                        <code class="filename">SDK_INHERIT_BLACKLIST</code> variable
                        as described in the previous section.
                        </p></li></ul></div><p>
                </p></li><li class="listitem"><p>
                Generally, you want to have a shared state mirror set up so
                users of the SDK can add additional items to the SDK after
                installation without needing to build the items from source.
                See the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-providing-additional-installable-extensible-sdk-content" title="B.6.Â Providing Additional Installable Extensible SDK Content">Providing Additional Installable Extensible SDK Content</a>"
                section for information.
                </p></li><li class="listitem"><p>
                If you want users of the SDK to be able to easily update the
                SDK, you need to set the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_UPDATE_URL" target="_top"><code class="filename">SDK_UPDATE_URL</code></a>
                variable.
                For more information, see the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-providing-updates-to-the-extensible-sdk-after-installation" title="B.4.Â Providing Updates to the Extensible SDK After Installation">Providing Updates to the Extensible SDK After Installation</a>"
                section.
                </p></li><li class="listitem"><p>
                If you have adjusted the list of files and directories that
                appear in
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-COREBASE" target="_top"><code class="filename">COREBASE</code></a>
                (other than layers that are enabled through
                <code class="filename">bblayers.conf</code>), then you must list these
                files in
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-COREBASE_FILES" target="_top"><code class="filename">COREBASE_FILES</code></a>
                so that the files are copied into the SDK.
                </p></li><li class="listitem"><p>
                If your OpenEmbedded build system setup uses a different
                environment setup script other than
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#structure-core-script" target="_top"><code class="filename">oe-init-build-env</code></a>,
                then you must set
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-OE_INIT_ENV_SCRIPT" target="_top"><code class="filename">OE_INIT_ENV_SCRIPT</code></a>
                to point to the environment setup script you use.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    You must also reflect this change in the value used for the
                    <code class="filename">COREBASE_FILES</code> variable as previously
                    described.
                </div><p>
                </p></li></ul></div><p>
    </p></div><div class="section" title="B.3.Â Changing the Extensible SDK Installer Title"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-changing-the-sdk-installer-title">B.3.&nbsp;Changing the Extensible SDK Installer Title<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-changing-the-sdk-installer-title">Â¶</a></span></h2></div></div></div><p>
        You can change the displayed title for the SDK installer by setting
        the
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_TITLE" target="_top"><code class="filename">SDK_TITLE</code></a>
        variable and then rebuilding the the SDK installer.
        For information on how to build an SDK installer, see the
        "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-building-an-sdk-installer" title="A.2.Â Building an SDK Installer">Building an SDK Installer</a>"
        section.
    </p><p>
        By default, this title is derived from
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-DISTRO_NAME" target="_top"><code class="filename">DISTRO_NAME</code></a>
        when it is set.
        If the <code class="filename">DISTRO_NAME</code> variable is not set, the title
        is derived from the
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-DISTRO" target="_top"><code class="filename">DISTRO</code></a>
        variable.
    </p><p>
        The
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-classes-populate-sdk-*" target="_top"><code class="filename">populate_sdk_base</code></a>
        class defines the default value of the <code class="filename">SDK_TITLE</code>
        variable as follows:
        </p><pre class="literallayout">     SDK_TITLE ??= "${@d.getVar('DISTRO_NAME') or d.getVar('DISTRO')} SDK"
        </pre><p>
    </p><p>
        While several ways exist to change this variable, an efficient method
        is to set the variable in your distribution's configuration file.
        Doing so creates an SDK installer title that applies across your
        distribution.
        As an example, assume you have your own layer for your distribution
        named "meta-mydistro" and you are using the same type of file
        hierarchy as does the default "poky" distribution.
        If so, you could update the <code class="filename">SDK_TITLE</code> variable
        in the
        <code class="filename">~/meta-mydistro/conf/distro/mydistro.conf</code> file
        using the following form:
        </p><pre class="literallayout">     SDK_TITLE = "<em class="replaceable"><code>your_title</code></em>"
        </pre><p>
    </p></div><div class="section" title="B.4.Â Providing Updates to the Extensible SDK After Installation"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-providing-updates-to-the-extensible-sdk-after-installation">B.4.&nbsp;Providing Updates to the Extensible SDK After Installation<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-providing-updates-to-the-extensible-sdk-after-installation">Â¶</a></span></h2></div></div></div><p>
        When you make changes to your configuration or to the metadata and
        if you want those changes to be reflected in installed SDKs, you need
        to perform additional steps.
        These steps make it possible for anyone using the installed SDKs to
        update the installed SDKs by using the
        <code class="filename">devtool sdk-update</code> command:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                Create a directory that can be shared over HTTP or HTTPS.
                You can do this by setting up a web server such as an
                <a class="ulink" href="https://en.wikipedia.org/wiki/Apache_HTTP_Server" target="_top">Apache HTTP Server</a>
                or
                <a class="ulink" href="https://en.wikipedia.org/wiki/Nginx" target="_top">Nginx</a>
                server in the cloud to host the directory.
                This directory must contain the published SDK.
                </p></li><li class="listitem"><p>
                Set the
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_UPDATE_URL" target="_top"><code class="filename">SDK_UPDATE_URL</code></a>
                variable to point to the corresponding HTTP or HTTPS URL.
                Setting this variable causes any SDK built to default to that
                URL and thus, the user does not have to pass the URL to the
                <code class="filename">devtool sdk-update</code> command as described
                in the
                "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-applying-updates-to-an-installed-extensible-sdk" title="2.9.Â Applying Updates to an Installed Extensible SDK">Applying Updates to an Installed Extensible SDK</a>"
                section.
                </p></li><li class="listitem"><p>
                Build the extensible SDK normally (i.e., use the
                <code class="filename">bitbake -c populate_sdk_ext</code> <em class="replaceable"><code>imagename</code></em>
                command).
                </p></li><li class="listitem"><p>
                Publish the SDK using the following command:
                </p><pre class="literallayout">     $ oe-publish-sdk <em class="replaceable"><code>some_path</code></em>/sdk-installer.sh <em class="replaceable"><code>path_to_shared_http_directory</code></em>
                </pre><p>
                You must repeat this step each time you rebuild the SDK
                with changes that you want to make available through the
                update mechanism.
                </p></li></ol></div><p>
    </p><p>
        Completing the above steps allows users of the existing installed
        SDKs to simply run <code class="filename">devtool sdk-update</code> to
        retrieve and apply the latest updates.
        See the
        "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-applying-updates-to-an-installed-extensible-sdk" title="2.9.Â Applying Updates to an Installed Extensible SDK">Applying Updates to an Installed Extensible SDK</a>"
        section for further information.
    </p></div><div class="section" title="B.5.Â Changing the Default SDK Installation Directory"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-changing-the-default-sdk-installation-directory">B.5.&nbsp;Changing the Default SDK Installation Directory<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-changing-the-default-sdk-installation-directory">Â¶</a></span></h2></div></div></div><p>
        When you build the installer for the Extensible SDK, the default
        installation directory for the SDK is based on the
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-DISTRO" target="_top"><code class="filename">DISTRO</code></a>
        and
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDKEXTPATH" target="_top"><code class="filename">SDKEXTPATH</code></a>
        variables from within the
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#ref-classes-populate-sdk-*" target="_top"><code class="filename">populate_sdk_base</code></a>
        class as follows:
        </p><pre class="literallayout">     SDKEXTPATH ??= "~/${@d.getVar('DISTRO')}_sdk"
        </pre><p>
        You can change this default installation directory by specifically
        setting the <code class="filename">SDKEXTPATH</code> variable.
    </p><p>
        While a number of ways exist through which you can set this variable,
        the method that makes the most sense is to set the variable in your
        distribution's configuration file.
        Doing so creates an SDK installer default directory that applies
        across your distribution.
        As an example, assume you have your own layer for your distribution
        named "meta-mydistro" and you are using the same type of file
        hierarchy as does the default "poky" distribution.
        If so, you could update the <code class="filename">SDKEXTPATH</code> variable
        in the
        <code class="filename">~/meta-mydistro/conf/distro/mydistro.conf</code> file
        using the following form:
        </p><pre class="literallayout">     SDKEXTPATH = "<em class="replaceable"><code>some_path_for_your_installed_sdk</code></em>"
        </pre><p>
    </p><p>
        After building your installer, running it prompts the user for
        acceptance of the
        <em class="replaceable"><code>some_path_for_your_installed_sdk</code></em> directory
        as the default location to install the Extensible SDK.
    </p></div><div class="section" title="B.6.Â Providing Additional Installable Extensible SDK Content"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-providing-additional-installable-extensible-sdk-content">B.6.&nbsp;Providing Additional Installable Extensible SDK Content<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-providing-additional-installable-extensible-sdk-content">Â¶</a></span></h2></div></div></div><p>
        If you want the users of an extensible SDK you build to be
        able to add items to the SDK without requiring the users to build
        the items from source, you need to do a number of things:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                Ensure the additional items you want the user to be able to
                install are already built:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        Build the items explicitly.
                        You could use one or more "meta" recipes that depend
                        on lists of other recipes.
                        </p></li><li class="listitem"><p>
                        Build the "world" target and set
                        <code class="filename">EXCLUDE_FROM_WORLD_pn-</code><em class="replaceable"><code>recipename</code></em>
                        for the recipes you do not want built.
                        See the
                        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-EXCLUDE_FROM_WORLD" target="_top"><code class="filename">EXCLUDE_FROM_WORLD</code></a>
                        variable for additional information.
                        </p></li></ul></div><p>
                </p></li><li class="listitem"><p>
                Expose the <code class="filename">sstate-cache</code> directory
                produced by the build.
                Typically, you expose this directory by making it available
                through an
                <a class="ulink" href="https://en.wikipedia.org/wiki/Apache_HTTP_Server" target="_top">Apache HTTP Server</a>
                or
                <a class="ulink" href="https://en.wikipedia.org/wiki/Nginx" target="_top">Nginx</a>
                server.
                </p></li><li class="listitem"><p>
                Set the appropriate configuration so that the produced SDK
                knows how to find the configuration.
                The variable you need to set is
                <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SSTATE_MIRRORS" target="_top"><code class="filename">SSTATE_MIRRORS</code></a>:
                </p><pre class="literallayout">     SSTATE_MIRRORS = "file://.*  http://<em class="replaceable"><code>example</code></em>.com/<em class="replaceable"><code>some_path</code></em>/sstate-cache/PATH"
                </pre><p>
                You can set the <code class="filename">SSTATE_MIRRORS</code> variable
                in two different places:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        If the mirror value you are setting is appropriate to
                        be set for both the OpenEmbedded build system that is
                        actually building the SDK and the SDK itself (i.e. the
                        mirror is accessible in both places or it will fail
                        quickly on the OpenEmbedded build system side, and its
                        contents will not interfere with the build), then you
                        can set the variable in your
                        <code class="filename">local.conf</code> or custom distro
                        configuration file.
                        You can then "whitelist" the variable through
                        to the SDK by adding the following:
                        </p><pre class="literallayout">     SDK_LOCAL_CONF_WHITELIST = "SSTATE_MIRRORS"
                        </pre><p>
                        </p></li><li class="listitem"><p>
                        Alternatively, if you just want to set the
                        <code class="filename">SSTATE_MIRRORS</code> variable's value
                        for the SDK alone, create a
                        <code class="filename">conf/sdk-extra.conf</code> file either in
                        your
                        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#build-directory" target="_top">Build Directory</a>
                        or within any layer and put your
                        <code class="filename">SSTATE_MIRRORS</code> setting within
                        that file.
                        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                            This second option is the safest option should
                            you have any doubts as to which method to use when
                            setting <code class="filename">SSTATE_MIRRORS</code>.
                        </div><p>
                        </p></li></ul></div><p>
                </p></li></ol></div><p>
    </p></div><div class="section" title="B.7.Â Minimizing the Size of the Extensible SDK Installer Download"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-minimizing-the-size-of-the-extensible-sdk-installer-download">B.7.&nbsp;Minimizing the Size of the Extensible SDK Installer Download<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-minimizing-the-size-of-the-extensible-sdk-installer-download">Â¶</a></span></h2></div></div></div><p>
        By default, the extensible SDK bundles the shared state artifacts for
        everything needed to reconstruct the image for which the SDK was built.
        This bundling can lead to an SDK installer file that is a Gigabyte or
        more in size.
        If the size of this file causes a problem, you can build an SDK that
        has just enough in it to install and provide access to the
        <code class="filename">devtool command</code> by setting the following in your
        configuration:
        </p><pre class="literallayout">     SDK_EXT_TYPE = "minimal"
        </pre><p>
        Setting
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_EXT_TYPE" target="_top"><code class="filename">SDK_EXT_TYPE</code></a>
        to "minimal" produces an SDK installer that is around 35 Mbytes in
        size, which downloads and installs quickly.
        You need to realize, though, that the minimal installer does not
        install any libraries or tools out of the box.
        These libraries and tools must be installed either "on the fly" or
        through actions you perform using <code class="filename">devtool</code> or
        explicitly with the <code class="filename">devtool sdk-install</code> command.
    </p><p>
        In most cases, when building a minimal SDK you need to also enable
        bringing in the information on a wider range of packages produced by
        the system.
        Requiring this wider range of information is particularly true
        so that <code class="filename">devtool add</code> is able to effectively map
        dependencies it discovers in a source tree to the appropriate recipes.
        Additionally, the information enables the
        <code class="filename">devtool search</code> command to return useful results.
    </p><p>
        To facilitate this wider range of information, you would need to
        set the following:
        </p><pre class="literallayout">     SDK_INCLUDE_PKGDATA = "1"
        </pre><p>
        See the
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_INCLUDE_PKGDATA" target="_top"><code class="filename">SDK_INCLUDE_PKGDATA</code></a>
        variable for additional information.
    </p><p>
        Setting the <code class="filename">SDK_INCLUDE_PKGDATA</code> variable as
        shown causes the "world" target to be built so that information
        for all of the recipes included within it are available.
        Having these recipes available increases build time significantly and
        increases the size of the SDK installer by 30-80 Mbytes depending on
        how many recipes are included in your configuration.
    </p><p>
        You can use
        <code class="filename">EXCLUDE_FROM_WORLD_pn-</code><em class="replaceable"><code>recipename</code></em>
        for recipes you want to exclude.
        However, it is assumed that you would need to be building the "world"
        target if you want to provide additional items to the SDK.
        Consequently, building for "world" should not represent undue
        overhead in most cases.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            If you set <code class="filename">SDK_EXT_TYPE</code> to "minimal",
            then providing a shared state mirror is mandatory so that items
            can be installed as needed.
            See the
            "<a class="link" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-providing-additional-installable-extensible-sdk-content" title="B.6.Â Providing Additional Installable Extensible SDK Content">Providing Additional Installable Extensible SDK Content</a>"
            section for more information.
        </div><p>
    </p><p>
        You can explicitly control whether or not to include the toolchain
        when you build an SDK by setting the
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-SDK_INCLUDE_TOOLCHAIN" target="_top"><code class="filename">SDK_INCLUDE_TOOLCHAIN</code></a>
        variable to "1".
        In particular, it is useful to include the toolchain when you
        have set <code class="filename">SDK_EXT_TYPE</code> to "minimal", which by
        default, excludes the toolchain.
        Also, it is helpful if you are building a small SDK for use with
        an IDE or some
        other tool where you do not want to take extra steps to install a
        toolchain.
    </p></div></div>

    <div class="appendix" title="AppendixÂ C.Â Customizing the Standard SDK" id="sdk-appendix-customizing-standard"><div class="titlepage"><div><div><h2 class="title">Appendix&nbsp;C.&nbsp;Customizing the Standard SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-appendix-customizing-standard">Â¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-individual-packages">C.1. Adding Individual Packages to the Standard SDK</a></span></dt><dt><span class="section"><a href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#adding-api-documentation-to-the-standard-sdk">C.2. Adding API Documentation to the Standard SDK</a></span></dt></dl></div><p>
    This appendix presents customizations you can apply to the standard SDK.
</p><div class="section" title="C.1.Â Adding Individual Packages to the Standard SDK"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="sdk-adding-individual-packages">C.1.&nbsp;Adding Individual Packages to the Standard SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#sdk-adding-individual-packages">Â¶</a></span></h2></div></div></div><p>
         When you build a standard SDK using the
         <code class="filename">bitbake -c populate_sdk</code>, a default set of
         packages is included in the resulting SDK.
         The
         <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-TOOLCHAIN_HOST_TASK" target="_top"><code class="filename">TOOLCHAIN_HOST_TASK</code></a>
         and
         <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-TOOLCHAIN_TARGET_TASK" target="_top"><code class="filename">TOOLCHAIN_TARGET_TASK</code></a>
         variables control the set of packages adding to the SDK.
    </p><p>
        If you want to add individual packages to the toolchain that runs on
        the host, simply add those packages to the
        <code class="filename">TOOLCHAIN_HOST_TASK</code> variable.
        Similarly, if you want to add packages to the default set that is
        part of the toolchain that runs on the target, add the packages to the
        <code class="filename">TOOLCHAIN_TARGET_TASK</code> variable.
    </p></div><div class="section" title="C.2.Â Adding API Documentation to the Standard SDK"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="adding-api-documentation-to-the-standard-sdk">C.2.&nbsp;Adding API Documentation to the Standard SDK<span class="permalink"><a alt="Permalink" title="Permalink" href="https://www.yoctoproject.org/docs/3.0.1/sdk-manual/sdk-manual.html#adding-api-documentation-to-the-standard-sdk">Â¶</a></span></h2></div></div></div><p>
        You can include API documentation as well as any other
        documentation provided by recipes with the standard SDK by
        adding "api-documentation" to the
        <a class="ulink" href="http://www.yoctoproject.org/docs/3.0.1/ref-manual/ref-manual.html#var-DISTRO_FEATURES" target="_top"><code class="filename">DISTRO_FEATURES</code></a>
        variable:
        </p><pre class="literallayout">     DISTRO_FEATURES_append = " api-documentation"
        </pre><p>
        Setting this variable as shown here causes the OpenEmbedded build
        system to build the documentation and then include it in the standard
        SDK.
    </p></div></div>



</div></body></html>